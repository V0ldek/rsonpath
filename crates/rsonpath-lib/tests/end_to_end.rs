// a408cf20bda680a9005e3d0ce325e327
use pretty_assertions::assert_eq;
use rsonpath::engine::{main::MainEngine, Compiler, Engine};
use rsonpath::input::*;
use rsonpath::query::JsonPathQuery;
use std::error::Error;
use std::fs;
use std::str;
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(453usize, 455usize, 455usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![453usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(453usize, 455usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(453usize, 455usize, 455usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![453usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(453usize, 455usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(453usize, 455usize, 455usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![453usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(453usize, 455usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(453usize, 455usize, 455usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![453usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(453usize, 455usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(453usize, 455usize, 455usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![453usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(453usize, 455usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(453usize, 455usize, 455usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![453usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(453usize, 455usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_compressed_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(810usize, 812usize, 817usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![810usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(810usize, 812usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(810usize, 812usize, 817usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![810usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(810usize, 812usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(810usize, 812usize, 817usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![810usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(810usize, 812usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_forcing_a_tail_skip_of_the_large_object_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $.a.b (look for the atomic value, forcing a tail-skip of the large object) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(810usize, 812usize, 817usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![810usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(810usize, 812usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(810usize, 812usize, 817usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![810usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(810usize, 812usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(810usize, 812usize, 817usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![810usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(810usize, 812usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_an_object_with_many_leaves_preceding_an_atomic_member_designed_to_stress_test_tail_skipping_with_query_look_for_the_atomic_value_with_descendant_forcing_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document skipping.toml running the query $..b (look for the atomic value with descendant, forcing memchr) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/skipping.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (100usize, 106usize, 106usize),
        (133usize, 139usize, 139usize),
        (153usize, 159usize, 159usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![100usize, 133usize, 153usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(100usize, 106usize), (133usize, 139usize), (153usize, 159usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"hit1\"", "\"hit2\"", "\"hit3\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (100usize, 106usize, 106usize),
        (133usize, 139usize, 139usize),
        (153usize, 159usize, 159usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![100usize, 133usize, 153usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(100usize, 106usize), (133usize, 139usize), (153usize, 159usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"hit1\"", "\"hit2\"", "\"hit3\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (100usize, 106usize, 106usize),
        (133usize, 139usize, 139usize),
        (153usize, 159usize, 159usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![100usize, 133usize, 153usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(100usize, 106usize), (133usize, 139usize), (153usize, 159usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_compressed_with_query_mix_descendant_and_child_names_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"hit1\"", "\"hit2\"", "\"hit3\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (986usize, 992usize, 1029usize),
        (1299usize, 1305usize, 1350usize),
        (1547usize, 1553usize, 1586usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![986usize, 1299usize, 1547usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(986usize, 992usize), (1299usize, 1305usize), (1547usize, 1553usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"hit1\"", "\"hit2\"", "\"hit3\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (986usize, 992usize, 1029usize),
        (1299usize, 1305usize, 1350usize),
        (1547usize, 1553usize, 1586usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![986usize, 1299usize, 1547usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(986usize, 992usize), (1299usize, 1305usize), (1547usize, 1553usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"hit1\"", "\"hit2\"", "\"hit3\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (986usize, 992usize, 1029usize),
        (1299usize, 1305usize, 1350usize),
        (1547usize, 1553usize, 1586usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![986usize, 1299usize, 1547usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(986usize, 992usize), (1299usize, 1305usize), (1547usize, 1553usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_deep_nesting_and_repeating_member_names_with_query_mix_descendant_and_child_names_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child.toml running the query $..a..b.c..d (mix descendant and child names) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b.c..d")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"hit1\"", "\"hit2\"", "\"hit3\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_by_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(27usize, 29usize, 29usize), (40usize, 42usize, 42usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![27usize, 40usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(27usize, 29usize), (40usize, 42usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_compressed_with_query_select_leaves_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_by_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..label (select leaves by memchr) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_tail_skipping_the_first_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $.a..label (select leaves tail-skipping the first element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(150usize, 152usize, 165usize), (257usize, 259usize, 272usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![150usize, 257usize,], "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(150usize, 152usize), (257usize, 259usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_excessive_whitespace_between_structural_colons_with_query_select_leaves_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document spaced_colon.toml running the query $..a..b..label (select leaves) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..label")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/spaced_colon.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (40usize, 48usize, 48usize),
        (109usize, 203usize, 203usize),
        (190usize, 198usize, 198usize),
        (241usize, 249usize, 249usize),
        (264usize, 272usize, 272usize),
        (281usize, 289usize, 289usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![40usize, 109usize, 190usize, 241usize, 264usize, 281usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (40usize, 48usize),
        (109usize, 203usize),
        (190usize, 198usize),
        (241usize, 249usize),
        (264usize, 272usize),
        (281usize, 289usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"value1\"" , "{\"v\":\"this c is also a hit\",\"c\":\"but this one is a miss\",\"a\":{\"b\":{\"a\":{\"b\":{\"c\":\"value2\"}}}}}" , "\"value2\"" , "\"value3\"" , "\"value4\"" , "\"value5\"" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (40usize, 48usize, 48usize),
        (109usize, 203usize, 203usize),
        (190usize, 198usize, 198usize),
        (241usize, 249usize, 249usize),
        (264usize, 272usize, 272usize),
        (281usize, 289usize, 289usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![40usize, 109usize, 190usize, 241usize, 264usize, 281usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (40usize, 48usize),
        (109usize, 203usize),
        (190usize, 198usize),
        (241usize, 249usize),
        (264usize, 272usize),
        (281usize, 289usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"value1\"" , "{\"v\":\"this c is also a hit\",\"c\":\"but this one is a miss\",\"a\":{\"b\":{\"a\":{\"b\":{\"c\":\"value2\"}}}}}" , "\"value2\"" , "\"value3\"" , "\"value4\"" , "\"value5\"" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (40usize, 48usize, 48usize),
        (109usize, 203usize, 203usize),
        (190usize, 198usize, 198usize),
        (241usize, 249usize, 249usize),
        (264usize, 272usize, 272usize),
        (281usize, 289usize, 289usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![40usize, 109usize, 190usize, 241usize, 264usize, 281usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (40usize, 48usize),
        (109usize, 203usize),
        (190usize, 198usize),
        (241usize, 249usize),
        (264usize, 272usize),
        (281usize, 289usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_compressed_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"value1\"" , "{\"v\":\"this c is also a hit\",\"c\":\"but this one is a miss\",\"a\":{\"b\":{\"a\":{\"b\":{\"c\":\"value2\"}}}}}" , "\"value2\"" , "\"value3\"" , "\"value4\"" , "\"value5\"" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (200usize, 208usize, 237usize),
        (758usize, 1507usize, 1548usize),
        (1229usize, 1237usize, 1298usize),
        (1905usize, 1913usize, 1913usize),
        (2042usize, 2050usize, 2087usize),
        (2209usize, 2217usize, 2238usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![200usize, 758usize, 1229usize, 1905usize, 2042usize, 2209usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (200usize, 208usize),
        (758usize, 1507usize),
        (1229usize, 1237usize),
        (1905usize, 1913usize),
        (2042usize, 2050usize),
        (2209usize, 2217usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"value1\"" , "{\n                                                \"v\": \"this c is also a hit\",\n                                                \"c\": \"but this one is a miss\",\n                                                \"a\": {\n                                                    \"b\": {\n                                                        \"a\": {\n                                                            \"b\": {\n                                                                \"c\": \"value2\"\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }" , "\"value2\"" , "\"value3\"" , "\"value4\"" , "\"value5\"" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (200usize, 208usize, 237usize),
        (758usize, 1507usize, 1548usize),
        (1229usize, 1237usize, 1298usize),
        (1905usize, 1913usize, 1913usize),
        (2042usize, 2050usize, 2087usize),
        (2209usize, 2217usize, 2238usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![200usize, 758usize, 1229usize, 1905usize, 2042usize, 2209usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (200usize, 208usize),
        (758usize, 1507usize),
        (1229usize, 1237usize),
        (1905usize, 1913usize),
        (2042usize, 2050usize),
        (2209usize, 2217usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"value1\"" , "{\n                                                \"v\": \"this c is also a hit\",\n                                                \"c\": \"but this one is a miss\",\n                                                \"a\": {\n                                                    \"b\": {\n                                                        \"a\": {\n                                                            \"b\": {\n                                                                \"c\": \"value2\"\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }" , "\"value2\"" , "\"value3\"" , "\"value4\"" , "\"value5\"" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (200usize, 208usize, 237usize),
        (758usize, 1507usize, 1548usize),
        (1229usize, 1237usize, 1298usize),
        (1905usize, 1913usize, 1913usize),
        (2042usize, 2050usize, 2087usize),
        (2209usize, 2217usize, 2238usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![200usize, 758usize, 1229usize, 1905usize, 2042usize, 2209usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (200usize, 208usize),
        (758usize, 1507usize),
        (1229usize, 1237usize),
        (1905usize, 1913usize),
        (2042usize, 2050usize),
        (2209usize, 2217usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn artificial_json_with_many_equal_member_names_nested_in_each_other_to_stress_test_child_name_selectors_with_query_select_the_path_ababc_with_repeating_members_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document child_hell.toml running the query $..x..a.b.a.b.c (select the path ababc with repeating members) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..x..a.b.a.b.c")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/child_hell.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"value1\"" , "{\n                                                \"v\": \"this c is also a hit\",\n                                                \"c\": \"but this one is a miss\",\n                                                \"a\": {\n                                                    \"b\": {\n                                                        \"a\": {\n                                                            \"b\": {\n                                                                \"c\": \"value2\"\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }" , "\"value2\"" , "\"value3\"" , "\"value4\"" , "\"value5\"" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (33usize, 35usize, 35usize),
        (44usize, 45usize, 45usize),
        (46usize, 47usize, 47usize),
        (48usize, 50usize, 50usize),
        (51usize, 53usize, 53usize),
        (54usize, 58usize, 58usize),
        (55usize, 57usize, 57usize),
        (59usize, 64usize, 64usize),
        (65usize, 69usize, 69usize),
        (70usize, 75usize, 75usize),
        (76usize, 80usize, 80usize),
        (92usize, 94usize, 94usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            33usize, 44usize, 46usize, 48usize, 51usize, 54usize, 55usize, 59usize, 65usize, 70usize, 76usize, 92usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (33usize, 35usize),
        (44usize, 45usize),
        (46usize, 47usize),
        (48usize, 50usize),
        (51usize, 53usize),
        (54usize, 58usize),
        (55usize, 57usize),
        (59usize, 64usize),
        (65usize, 69usize),
        (70usize, 75usize),
        (76usize, 80usize),
        (92usize, 94usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42", "1", "2", "{}", "[]", "[[]]", "[]", "\"xyz\"", "true", "false", "null", "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (33usize, 35usize, 35usize),
        (44usize, 45usize, 45usize),
        (46usize, 47usize, 47usize),
        (48usize, 50usize, 50usize),
        (51usize, 53usize, 53usize),
        (54usize, 58usize, 58usize),
        (55usize, 57usize, 57usize),
        (59usize, 64usize, 64usize),
        (65usize, 69usize, 69usize),
        (70usize, 75usize, 75usize),
        (76usize, 80usize, 80usize),
        (92usize, 94usize, 94usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            33usize, 44usize, 46usize, 48usize, 51usize, 54usize, 55usize, 59usize, 65usize, 70usize, 76usize, 92usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (33usize, 35usize),
        (44usize, 45usize),
        (46usize, 47usize),
        (48usize, 50usize),
        (51usize, 53usize),
        (54usize, 58usize),
        (55usize, 57usize),
        (59usize, 64usize),
        (65usize, 69usize),
        (70usize, 75usize),
        (76usize, 80usize),
        (92usize, 94usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42", "1", "2", "{}", "[]", "[[]]", "[]", "\"xyz\"", "true", "false", "null", "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (33usize, 35usize, 35usize),
        (44usize, 45usize, 45usize),
        (46usize, 47usize, 47usize),
        (48usize, 50usize, 50usize),
        (51usize, 53usize, 53usize),
        (54usize, 58usize, 58usize),
        (55usize, 57usize, 57usize),
        (59usize, 64usize, 64usize),
        (65usize, 69usize, 69usize),
        (70usize, 75usize, 75usize),
        (76usize, 80usize, 80usize),
        (92usize, 94usize, 94usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            33usize, 44usize, 46usize, 48usize, 51usize, 54usize, 55usize, 59usize, 65usize, 70usize, 76usize, 92usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (33usize, 35usize),
        (44usize, 45usize),
        (46usize, 47usize),
        (48usize, 50usize),
        (51usize, 53usize),
        (54usize, 58usize),
        (55usize, 57usize),
        (59usize, 64usize),
        (65usize, 69usize),
        (70usize, 75usize),
        (76usize, 80usize),
        (92usize, 94usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42", "1", "2", "{}", "[]", "[[]]", "[]", "\"xyz\"", "true", "false", "null", "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (33usize, 35usize, 35usize),
        (44usize, 45usize, 45usize),
        (46usize, 47usize, 47usize),
        (48usize, 50usize, 50usize),
        (51usize, 53usize, 53usize),
        (54usize, 58usize, 58usize),
        (59usize, 64usize, 64usize),
        (65usize, 69usize, 69usize),
        (70usize, 75usize, 75usize),
        (76usize, 80usize, 80usize),
        (92usize, 94usize, 94usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![33usize, 44usize, 46usize, 48usize, 51usize, 54usize, 59usize, 65usize, 70usize, 76usize, 92usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (33usize, 35usize),
        (44usize, 45usize),
        (46usize, 47usize),
        (48usize, 50usize),
        (51usize, 53usize),
        (54usize, 58usize),
        (59usize, 64usize),
        (65usize, 69usize),
        (70usize, 75usize),
        (76usize, 80usize),
        (92usize, 94usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42", "1", "2", "{}", "[]", "[[]]", "\"xyz\"", "true", "false", "null", "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (33usize, 35usize, 35usize),
        (44usize, 45usize, 45usize),
        (46usize, 47usize, 47usize),
        (48usize, 50usize, 50usize),
        (51usize, 53usize, 53usize),
        (54usize, 58usize, 58usize),
        (59usize, 64usize, 64usize),
        (65usize, 69usize, 69usize),
        (70usize, 75usize, 75usize),
        (76usize, 80usize, 80usize),
        (92usize, 94usize, 94usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![33usize, 44usize, 46usize, 48usize, 51usize, 54usize, 59usize, 65usize, 70usize, 76usize, 92usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (33usize, 35usize),
        (44usize, 45usize),
        (46usize, 47usize),
        (48usize, 50usize),
        (51usize, 53usize),
        (54usize, 58usize),
        (59usize, 64usize),
        (65usize, 69usize),
        (70usize, 75usize),
        (76usize, 80usize),
        (92usize, 94usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42", "1", "2", "{}", "[]", "[[]]", "\"xyz\"", "true", "false", "null", "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (33usize, 35usize, 35usize),
        (44usize, 45usize, 45usize),
        (46usize, 47usize, 47usize),
        (48usize, 50usize, 50usize),
        (51usize, 53usize, 53usize),
        (54usize, 58usize, 58usize),
        (59usize, 64usize, 64usize),
        (65usize, 69usize, 69usize),
        (70usize, 75usize, 75usize),
        (76usize, 80usize, 80usize),
        (92usize, 94usize, 94usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![33usize, 44usize, 46usize, 48usize, 51usize, 54usize, 59usize, 65usize, 70usize, 76usize, 92usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (33usize, 35usize),
        (44usize, 45usize),
        (46usize, 47usize),
        (48usize, 50usize),
        (51usize, 53usize),
        (54usize, 58usize),
        (59usize, 64usize),
        (65usize, 69usize),
        (70usize, 75usize),
        (76usize, 80usize),
        (92usize, 94usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_compressed_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42", "1", "2", "{}", "[]", "[[]]", "\"xyz\"", "true", "false", "null", "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (228usize, 230usize, 263usize),
        (401usize, 402usize, 402usize),
        (440usize, 441usize, 441usize),
        (479usize, 481usize, 481usize),
        (519usize, 521usize, 521usize),
        (559usize, 641usize, 641usize),
        (601usize, 603usize, 640usize),
        (679usize, 684usize, 684usize),
        (722usize, 726usize, 726usize),
        (764usize, 769usize, 769usize),
        (807usize, 811usize, 844usize),
        (1012usize, 1014usize, 1035usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            228usize, 401usize, 440usize, 479usize, 519usize, 559usize, 601usize, 679usize, 722usize, 764usize,
            807usize, 1012usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (228usize, 230usize),
        (401usize, 402usize),
        (440usize, 441usize),
        (479usize, 481usize),
        (519usize, 521usize),
        (559usize, 641usize),
        (601usize, 603usize),
        (679usize, 684usize),
        (722usize, 726usize),
        (764usize, 769usize),
        (807usize, 811usize),
        (1012usize, 1014usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "1",
        "2",
        "{}",
        "[]",
        "[\n                                        []\n                                    ]",
        "[]",
        "\"xyz\"",
        "true",
        "false",
        "null",
        "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (228usize, 230usize, 263usize),
        (401usize, 402usize, 402usize),
        (440usize, 441usize, 441usize),
        (479usize, 481usize, 481usize),
        (519usize, 521usize, 521usize),
        (559usize, 641usize, 641usize),
        (601usize, 603usize, 640usize),
        (679usize, 684usize, 684usize),
        (722usize, 726usize, 726usize),
        (764usize, 769usize, 769usize),
        (807usize, 811usize, 844usize),
        (1012usize, 1014usize, 1035usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            228usize, 401usize, 440usize, 479usize, 519usize, 559usize, 601usize, 679usize, 722usize, 764usize,
            807usize, 1012usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (228usize, 230usize),
        (401usize, 402usize),
        (440usize, 441usize),
        (479usize, 481usize),
        (519usize, 521usize),
        (559usize, 641usize),
        (601usize, 603usize),
        (679usize, 684usize),
        (722usize, 726usize),
        (764usize, 769usize),
        (807usize, 811usize),
        (1012usize, 1014usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "1",
        "2",
        "{}",
        "[]",
        "[\n                                        []\n                                    ]",
        "[]",
        "\"xyz\"",
        "true",
        "false",
        "null",
        "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (228usize, 230usize, 263usize),
        (401usize, 402usize, 402usize),
        (440usize, 441usize, 441usize),
        (479usize, 481usize, 481usize),
        (519usize, 521usize, 521usize),
        (559usize, 641usize, 641usize),
        (601usize, 603usize, 640usize),
        (679usize, 684usize, 684usize),
        (722usize, 726usize, 726usize),
        (764usize, 769usize, 769usize),
        (807usize, 811usize, 844usize),
        (1012usize, 1014usize, 1035usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            228usize, 401usize, 440usize, 479usize, 519usize, 559usize, 601usize, 679usize, 722usize, 764usize,
            807usize, 1012usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (228usize, 230usize),
        (401usize, 402usize),
        (440usize, 441usize),
        (479usize, 481usize),
        (519usize, 521usize),
        (559usize, 641usize),
        (601usize, 603usize),
        (679usize, 684usize),
        (722usize, 726usize),
        (764usize, 769usize),
        (807usize, 811usize),
        (1012usize, 1014usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_descendant_segments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a..*..b..* (select all nodes in bs with descendant segments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*..b..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "1",
        "2",
        "{}",
        "[]",
        "[\n                                        []\n                                    ]",
        "[]",
        "\"xyz\"",
        "true",
        "false",
        "null",
        "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (228usize, 230usize, 263usize),
        (401usize, 402usize, 402usize),
        (440usize, 441usize, 441usize),
        (479usize, 481usize, 481usize),
        (519usize, 521usize, 521usize),
        (559usize, 641usize, 641usize),
        (679usize, 684usize, 684usize),
        (722usize, 726usize, 726usize),
        (764usize, 769usize, 769usize),
        (807usize, 811usize, 844usize),
        (1012usize, 1014usize, 1035usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            228usize, 401usize, 440usize, 479usize, 519usize, 559usize, 679usize, 722usize, 764usize, 807usize,
            1012usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (228usize, 230usize),
        (401usize, 402usize),
        (440usize, 441usize),
        (479usize, 481usize),
        (519usize, 521usize),
        (559usize, 641usize),
        (679usize, 684usize),
        (722usize, 726usize),
        (764usize, 769usize),
        (807usize, 811usize),
        (1012usize, 1014usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "1",
        "2",
        "{}",
        "[]",
        "[\n                                        []\n                                    ]",
        "\"xyz\"",
        "true",
        "false",
        "null",
        "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (228usize, 230usize, 263usize),
        (401usize, 402usize, 402usize),
        (440usize, 441usize, 441usize),
        (479usize, 481usize, 481usize),
        (519usize, 521usize, 521usize),
        (559usize, 641usize, 641usize),
        (679usize, 684usize, 684usize),
        (722usize, 726usize, 726usize),
        (764usize, 769usize, 769usize),
        (807usize, 811usize, 844usize),
        (1012usize, 1014usize, 1035usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            228usize, 401usize, 440usize, 479usize, 519usize, 559usize, 679usize, 722usize, 764usize, 807usize,
            1012usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (228usize, 230usize),
        (401usize, 402usize),
        (440usize, 441usize),
        (479usize, 481usize),
        (519usize, 521usize),
        (559usize, 641usize),
        (679usize, 684usize),
        (722usize, 726usize),
        (764usize, 769usize),
        (807usize, 811usize),
        (1012usize, 1014usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "1",
        "2",
        "{}",
        "[]",
        "[\n                                        []\n                                    ]",
        "\"xyz\"",
        "true",
        "false",
        "null",
        "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (228usize, 230usize, 263usize),
        (401usize, 402usize, 402usize),
        (440usize, 441usize, 441usize),
        (479usize, 481usize, 481usize),
        (519usize, 521usize, 521usize),
        (559usize, 641usize, 641usize),
        (679usize, 684usize, 684usize),
        (722usize, 726usize, 726usize),
        (764usize, 769usize, 769usize),
        (807usize, 811usize, 844usize),
        (1012usize, 1014usize, 1035usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            228usize, 401usize, 440usize, 479usize, 519usize, 559usize, 679usize, 722usize, 764usize, 807usize,
            1012usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (228usize, 230usize),
        (401usize, 402usize),
        (440usize, 441usize),
        (479usize, 481usize),
        (519usize, 521usize),
        (559usize, 641usize),
        (679usize, 684usize),
        (722usize, 726usize),
        (764usize, 769usize),
        (807usize, 811usize),
        (1012usize, 1014usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_list_with_all_data_types_with_query_select_all_nodes_in_bs_with_mixed_segments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document deeply_nested_heterogenous_list.toml running the query $..a.*..b.* (select all nodes in bs with mixed segments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*..b.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/deeply_nested_heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "1",
        "2",
        "{}",
        "[]",
        "[\n                                        []\n                                    ]",
        "\"xyz\"",
        "true",
        "false",
        "null",
        "42",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 17usize, 17usize),
        (18usize, 19usize, 19usize),
        (20usize, 22usize, 22usize),
        (23usize, 25usize, 25usize),
        (26usize, 34usize, 34usize),
        (27usize, 33usize, 33usize),
        (28usize, 32usize, 32usize),
        (29usize, 31usize, 31usize),
        (35usize, 36usize, 36usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 18usize, 20usize, 23usize, 26usize, 27usize, 28usize, 29usize, 35usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 17usize),
        (18usize, 19usize),
        (20usize, 22usize),
        (23usize, 25usize),
        (26usize, 34usize),
        (27usize, 33usize),
        (28usize, 32usize),
        (29usize, 31usize),
        (35usize, 36usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "{}", "[]", "[[[[]]]]", "[[[]]]", "[[]]", "[]", "3"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 17usize, 17usize),
        (18usize, 19usize, 19usize),
        (20usize, 22usize, 22usize),
        (23usize, 25usize, 25usize),
        (26usize, 34usize, 34usize),
        (27usize, 33usize, 33usize),
        (28usize, 32usize, 32usize),
        (29usize, 31usize, 31usize),
        (35usize, 36usize, 36usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 18usize, 20usize, 23usize, 26usize, 27usize, 28usize, 29usize, 35usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 17usize),
        (18usize, 19usize),
        (20usize, 22usize),
        (23usize, 25usize),
        (26usize, 34usize),
        (27usize, 33usize),
        (28usize, 32usize),
        (29usize, 31usize),
        (35usize, 36usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "{}", "[]", "[[[[]]]]", "[[[]]]", "[[]]", "[]", "3"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 17usize, 17usize),
        (18usize, 19usize, 19usize),
        (20usize, 22usize, 22usize),
        (23usize, 25usize, 25usize),
        (26usize, 34usize, 34usize),
        (27usize, 33usize, 33usize),
        (28usize, 32usize, 32usize),
        (29usize, 31usize, 31usize),
        (35usize, 36usize, 36usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 18usize, 20usize, 23usize, 26usize, 27usize, 28usize, 29usize, 35usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 17usize),
        (18usize, 19usize),
        (20usize, 22usize),
        (23usize, 25usize),
        (26usize, 34usize),
        (27usize, 33usize),
        (28usize, 32usize),
        (29usize, 31usize),
        (35usize, 36usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "{}", "[]", "[[[[]]]]", "[[[]]]", "[[]]", "[]", "3"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 17usize, 17usize),
        (18usize, 19usize, 19usize),
        (20usize, 22usize, 22usize),
        (23usize, 25usize, 25usize),
        (26usize, 34usize, 34usize),
        (35usize, 36usize, 36usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 18usize, 20usize, 23usize, 26usize, 35usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 17usize),
        (18usize, 19usize),
        (20usize, 22usize),
        (23usize, 25usize),
        (26usize, 34usize),
        (35usize, 36usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "{}", "[]", "[[[[]]]]", "3"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 17usize, 17usize),
        (18usize, 19usize, 19usize),
        (20usize, 22usize, 22usize),
        (23usize, 25usize, 25usize),
        (26usize, 34usize, 34usize),
        (35usize, 36usize, 36usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 18usize, 20usize, 23usize, 26usize, 35usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 17usize),
        (18usize, 19usize),
        (20usize, 22usize),
        (23usize, 25usize),
        (26usize, 34usize),
        (35usize, 36usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "{}", "[]", "[[[[]]]]", "3"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 17usize, 17usize),
        (18usize, 19usize, 19usize),
        (20usize, 22usize, 22usize),
        (23usize, 25usize, 25usize),
        (26usize, 34usize, 34usize),
        (35usize, 36usize, 36usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 18usize, 20usize, 23usize, 26usize, 35usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 17usize),
        (18usize, 19usize),
        (20usize, 22usize),
        (23usize, 25usize),
        (26usize, 34usize),
        (35usize, 36usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_compressed_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "{}", "[]", "[[[[]]]]", "3"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (63usize, 64usize, 64usize),
        (82usize, 83usize, 83usize),
        (101usize, 103usize, 103usize),
        (121usize, 123usize, 123usize),
        (141usize, 287usize, 287usize),
        (163usize, 269usize, 286usize),
        (189usize, 247usize, 268usize),
        (219usize, 221usize, 246usize),
        (305usize, 306usize, 319usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![63usize, 82usize, 101usize, 121usize, 141usize, 163usize, 189usize, 219usize, 305usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (63usize, 64usize),
        (82usize, 83usize),
        (101usize, 103usize),
        (121usize, 123usize),
        (141usize, 287usize),
        (163usize, 269usize),
        (189usize, 247usize),
        (219usize, 221usize),
        (305usize, 306usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["1" , "2" , "{}" , "[]" , "[\n                    [\n                        [\n                            []\n                        ]\n                    ]\n                ]" , "[\n                        [\n                            []\n                        ]\n                    ]" , "[\n                            []\n                        ]" , "[]" , "3" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (63usize, 64usize, 64usize),
        (82usize, 83usize, 83usize),
        (101usize, 103usize, 103usize),
        (121usize, 123usize, 123usize),
        (141usize, 287usize, 287usize),
        (163usize, 269usize, 286usize),
        (189usize, 247usize, 268usize),
        (219usize, 221usize, 246usize),
        (305usize, 306usize, 319usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![63usize, 82usize, 101usize, 121usize, 141usize, 163usize, 189usize, 219usize, 305usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (63usize, 64usize),
        (82usize, 83usize),
        (101usize, 103usize),
        (121usize, 123usize),
        (141usize, 287usize),
        (163usize, 269usize),
        (189usize, 247usize),
        (219usize, 221usize),
        (305usize, 306usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["1" , "2" , "{}" , "[]" , "[\n                    [\n                        [\n                            []\n                        ]\n                    ]\n                ]" , "[\n                        [\n                            []\n                        ]\n                    ]" , "[\n                            []\n                        ]" , "[]" , "3" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (63usize, 64usize, 64usize),
        (82usize, 83usize, 83usize),
        (101usize, 103usize, 103usize),
        (121usize, 123usize, 123usize),
        (141usize, 287usize, 287usize),
        (163usize, 269usize, 286usize),
        (189usize, 247usize, 268usize),
        (219usize, 221usize, 246usize),
        (305usize, 306usize, 319usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![63usize, 82usize, 101usize, 121usize, 141usize, 163usize, 189usize, 219usize, 305usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (63usize, 64usize),
        (82usize, 83usize),
        (101usize, 103usize),
        (121usize, 123usize),
        (141usize, 287usize),
        (163usize, 269usize),
        (189usize, 247usize),
        (219usize, 221usize),
        (305usize, 306usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_and_below_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a..* (select all nodes in the top-level list and below) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["1" , "2" , "{}" , "[]" , "[\n                    [\n                        [\n                            []\n                        ]\n                    ]\n                ]" , "[\n                        [\n                            []\n                        ]\n                    ]" , "[\n                            []\n                        ]" , "[]" , "3" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (63usize, 64usize, 64usize),
        (82usize, 83usize, 83usize),
        (101usize, 103usize, 103usize),
        (121usize, 123usize, 123usize),
        (141usize, 287usize, 287usize),
        (305usize, 306usize, 319usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![63usize, 82usize, 101usize, 121usize, 141usize, 305usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (63usize, 64usize),
        (82usize, 83usize),
        (101usize, 103usize),
        (121usize, 123usize),
        (141usize, 287usize),
        (305usize, 306usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["1" , "2" , "{}" , "[]" , "[\n                    [\n                        [\n                            []\n                        ]\n                    ]\n                ]" , "3" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (63usize, 64usize, 64usize),
        (82usize, 83usize, 83usize),
        (101usize, 103usize, 103usize),
        (121usize, 123usize, 123usize),
        (141usize, 287usize, 287usize),
        (305usize, 306usize, 319usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![63usize, 82usize, 101usize, 121usize, 141usize, 305usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (63usize, 64usize),
        (82usize, 83usize),
        (101usize, 103usize),
        (121usize, 123usize),
        (141usize, 287usize),
        (305usize, 306usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["1" , "2" , "{}" , "[]" , "[\n                    [\n                        [\n                            []\n                        ]\n                    ]\n                ]" , "3" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (63usize, 64usize, 64usize),
        (82usize, 83usize, 83usize),
        (101usize, 103usize, 103usize),
        (121usize, 123usize, 123usize),
        (141usize, 287usize, 287usize),
        (305usize, 306usize, 319usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![63usize, 82usize, 101usize, 121usize, 141usize, 305usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (63usize, 64usize),
        (82usize, 83usize),
        (101usize, 103usize),
        (121usize, 123usize),
        (141usize, 287usize),
        (305usize, 306usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_lists_with_query_select_all_nodes_in_the_top_level_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document matrioshka_list.toml running the query $..a.* (select all nodes in the top-level list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/matrioshka_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["1" , "2" , "{}" , "[]" , "[\n                    [\n                        [\n                            []\n                        ]\n                    ]\n                ]" , "3" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (253usize, 270usize, 270usize),
        (280usize, 284usize, 284usize),
        (290usize, 693usize, 693usize),
        (298usize, 318usize, 318usize),
        (328usize, 332usize, 332usize),
        (338usize, 692usize, 692usize),
        (570usize, 604usize, 604usize),
        (614usize, 618usize, 618usize),
        (625usize, 687usize, 687usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![253usize, 280usize, 290usize, 298usize, 328usize, 338usize, 570usize, 614usize, 625usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (253usize, 270usize),
        (280usize, 284usize),
        (290usize, 693usize),
        (298usize, 318usize),
        (328usize, 332usize),
        (338usize, 692usize),
        (570usize, 604usize),
        (614usize, 618usize),
        (625usize, 687usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"$.x1.a.a.x2.b.b\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5\",\"is_hit\":true,\"x6\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6\",\"is_hit\":false,\"x7\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7\",\"is_hit\":false,\"x8\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\"is_hit\":false,\"b\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\"is_hit\":false,\"x9\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\"is_hit\":true,\"x10\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}}}}}}}" , "\"$.x1.a.a.x2.b.b.x5\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5.x6\",\"is_hit\":false,\"x7\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7\",\"is_hit\":false,\"x8\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\"is_hit\":false,\"b\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\"is_hit\":false,\"x9\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\"is_hit\":true,\"x10\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}}}}}}" , "\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (253usize, 270usize, 270usize),
        (280usize, 284usize, 284usize),
        (290usize, 693usize, 693usize),
        (298usize, 318usize, 318usize),
        (328usize, 332usize, 332usize),
        (338usize, 692usize, 692usize),
        (570usize, 604usize, 604usize),
        (614usize, 618usize, 618usize),
        (625usize, 687usize, 687usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![253usize, 280usize, 290usize, 298usize, 328usize, 338usize, 570usize, 614usize, 625usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (253usize, 270usize),
        (280usize, 284usize),
        (290usize, 693usize),
        (298usize, 318usize),
        (328usize, 332usize),
        (338usize, 692usize),
        (570usize, 604usize),
        (614usize, 618usize),
        (625usize, 687usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"$.x1.a.a.x2.b.b\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5\",\"is_hit\":true,\"x6\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6\",\"is_hit\":false,\"x7\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7\",\"is_hit\":false,\"x8\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\"is_hit\":false,\"b\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\"is_hit\":false,\"x9\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\"is_hit\":true,\"x10\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}}}}}}}" , "\"$.x1.a.a.x2.b.b.x5\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5.x6\",\"is_hit\":false,\"x7\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7\",\"is_hit\":false,\"x8\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\"is_hit\":false,\"b\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\"is_hit\":false,\"x9\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\"is_hit\":true,\"x10\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}}}}}}" , "\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (253usize, 270usize, 270usize),
        (280usize, 284usize, 284usize),
        (290usize, 693usize, 693usize),
        (298usize, 318usize, 318usize),
        (328usize, 332usize, 332usize),
        (338usize, 692usize, 692usize),
        (570usize, 604usize, 604usize),
        (614usize, 618usize, 618usize),
        (625usize, 687usize, 687usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![253usize, 280usize, 290usize, 298usize, 328usize, 338usize, 570usize, 614usize, 625usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (253usize, 270usize),
        (280usize, 284usize),
        (290usize, 693usize),
        (298usize, 318usize),
        (328usize, 332usize),
        (338usize, 692usize),
        (570usize, 604usize),
        (614usize, 618usize),
        (625usize, 687usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_compressed_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"$.x1.a.a.x2.b.b\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5\",\"is_hit\":true,\"x6\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6\",\"is_hit\":false,\"x7\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7\",\"is_hit\":false,\"x8\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\"is_hit\":false,\"b\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\"is_hit\":false,\"x9\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\"is_hit\":true,\"x10\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}}}}}}}" , "\"$.x1.a.a.x2.b.b.x5\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5.x6\",\"is_hit\":false,\"x7\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7\",\"is_hit\":false,\"x8\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\"is_hit\":false,\"b\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\"is_hit\":false,\"x9\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\"is_hit\":true,\"x10\":{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}}}}}}" , "\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\"" , "true" , "{\"path\":\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\"is_hit\":false}" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (654usize, 671usize, 671usize),
        (711usize, 715usize, 715usize),
        (751usize, 2349usize, 2374usize),
        (793usize, 813usize, 813usize),
        (857usize, 861usize, 861usize),
        (901usize, 2319usize, 2348usize),
        (1715usize, 1749usize, 1749usize),
        (1813usize, 1817usize, 1817usize),
        (1878usize, 2109usize, 2158usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![654usize, 711usize, 751usize, 793usize, 857usize, 901usize, 1715usize, 1813usize, 1878usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (654usize, 671usize),
        (711usize, 715usize),
        (751usize, 2349usize),
        (793usize, 813usize),
        (857usize, 861usize),
        (901usize, 2319usize),
        (1715usize, 1749usize),
        (1813usize, 1817usize),
        (1878usize, 2109usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"$.x1.a.a.x2.b.b\"" , "true" , "{\n                                \"path\": \"$.x1.a.a.x2.b.b.x5\",\n                                \"is_hit\": true,\n                                \"x6\": {\n                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6\",\n                                    \"is_hit\": false,\n                                    \"x7\": {\n                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7\",\n                                        \"is_hit\": false,\n                                        \"x8\": {\n                                            \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\n                                            \"is_hit\": false,\n                                            \"b\": {\n                                                \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\n                                                \"is_hit\": false,\n                                                \"x9\": {\n                                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\n                                                    \"is_hit\": true,\n                                                    \"x10\": {\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }" , "\"$.x1.a.a.x2.b.b.x5\"" , "true" , "{\n                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6\",\n                                    \"is_hit\": false,\n                                    \"x7\": {\n                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7\",\n                                        \"is_hit\": false,\n                                        \"x8\": {\n                                            \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\n                                            \"is_hit\": false,\n                                            \"b\": {\n                                                \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\n                                                \"is_hit\": false,\n                                                \"x9\": {\n                                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\n                                                    \"is_hit\": true,\n                                                    \"x10\": {\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }" , "\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\"" , "true" , "{\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (654usize, 671usize, 671usize),
        (711usize, 715usize, 715usize),
        (751usize, 2349usize, 2374usize),
        (793usize, 813usize, 813usize),
        (857usize, 861usize, 861usize),
        (901usize, 2319usize, 2348usize),
        (1715usize, 1749usize, 1749usize),
        (1813usize, 1817usize, 1817usize),
        (1878usize, 2109usize, 2158usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![654usize, 711usize, 751usize, 793usize, 857usize, 901usize, 1715usize, 1813usize, 1878usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (654usize, 671usize),
        (711usize, 715usize),
        (751usize, 2349usize),
        (793usize, 813usize),
        (857usize, 861usize),
        (901usize, 2319usize),
        (1715usize, 1749usize),
        (1813usize, 1817usize),
        (1878usize, 2109usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"$.x1.a.a.x2.b.b\"" , "true" , "{\n                                \"path\": \"$.x1.a.a.x2.b.b.x5\",\n                                \"is_hit\": true,\n                                \"x6\": {\n                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6\",\n                                    \"is_hit\": false,\n                                    \"x7\": {\n                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7\",\n                                        \"is_hit\": false,\n                                        \"x8\": {\n                                            \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\n                                            \"is_hit\": false,\n                                            \"b\": {\n                                                \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\n                                                \"is_hit\": false,\n                                                \"x9\": {\n                                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\n                                                    \"is_hit\": true,\n                                                    \"x10\": {\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }" , "\"$.x1.a.a.x2.b.b.x5\"" , "true" , "{\n                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6\",\n                                    \"is_hit\": false,\n                                    \"x7\": {\n                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7\",\n                                        \"is_hit\": false,\n                                        \"x8\": {\n                                            \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\n                                            \"is_hit\": false,\n                                            \"b\": {\n                                                \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\n                                                \"is_hit\": false,\n                                                \"x9\": {\n                                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\n                                                    \"is_hit\": true,\n                                                    \"x10\": {\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }" , "\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\"" , "true" , "{\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (654usize, 671usize, 671usize),
        (711usize, 715usize, 715usize),
        (751usize, 2349usize, 2374usize),
        (793usize, 813usize, 813usize),
        (857usize, 861usize, 861usize),
        (901usize, 2319usize, 2348usize),
        (1715usize, 1749usize, 1749usize),
        (1813usize, 1817usize, 1817usize),
        (1878usize, 2109usize, 2158usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9u64, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![654usize, 711usize, 751usize, 793usize, 857usize, 901usize, 1715usize, 1813usize, 1878usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (654usize, 671usize),
        (711usize, 715usize),
        (751usize, 2349usize),
        (793usize, 813usize),
        (857usize, 861usize),
        (901usize, 2319usize),
        (1715usize, 1749usize),
        (1813usize, 1817usize),
        (1878usize, 2109usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn deeply_nested_object_with_path_annotations_with_query_descendant_a_star_star_then_descendant_b_star_star_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document long_path.toml running the query $..a.*.*..b.*.* (descendant a star star, then descendant b star star) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*.*..b.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/long_path.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["\"$.x1.a.a.x2.b.b\"" , "true" , "{\n                                \"path\": \"$.x1.a.a.x2.b.b.x5\",\n                                \"is_hit\": true,\n                                \"x6\": {\n                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6\",\n                                    \"is_hit\": false,\n                                    \"x7\": {\n                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7\",\n                                        \"is_hit\": false,\n                                        \"x8\": {\n                                            \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\n                                            \"is_hit\": false,\n                                            \"b\": {\n                                                \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\n                                                \"is_hit\": false,\n                                                \"x9\": {\n                                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\n                                                    \"is_hit\": true,\n                                                    \"x10\": {\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }" , "\"$.x1.a.a.x2.b.b.x5\"" , "true" , "{\n                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6\",\n                                    \"is_hit\": false,\n                                    \"x7\": {\n                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7\",\n                                        \"is_hit\": false,\n                                        \"x8\": {\n                                            \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8\",\n                                            \"is_hit\": false,\n                                            \"b\": {\n                                                \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b\",\n                                                \"is_hit\": false,\n                                                \"x9\": {\n                                                    \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\",\n                                                    \"is_hit\": true,\n                                                    \"x10\": {\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }" , "\"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9\"" , "true" , "{\n                                                        \"path\": \"$.x1.a.a.x2.b.b.x5.x6.x7.x8.b.x9.x10\",\n                                                        \"is_hit\": false\n                                                    }" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (20usize, 22usize, 22usize),
        (27usize, 29usize, 29usize),
        (34usize, 36usize, 36usize),
        (41usize, 49usize, 49usize),
        (46usize, 48usize, 48usize),
        (54usize, 69usize, 69usize),
        (59usize, 61usize, 61usize),
        (66usize, 68usize, 68usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![20usize, 27usize, 34usize, 41usize, 46usize, 54usize, 59usize, 66usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (20usize, 22usize),
        (27usize, 29usize),
        (34usize, 36usize),
        (41usize, 49usize),
        (46usize, 48usize),
        (54usize, 69usize),
        (59usize, 61usize),
        (66usize, 68usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "43", "44", "{\"x\":45}", "45", "{\"a\":46,\"x\":47}", "46", "47"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (20usize, 22usize, 22usize),
        (27usize, 29usize, 29usize),
        (34usize, 36usize, 36usize),
        (41usize, 49usize, 49usize),
        (46usize, 48usize, 48usize),
        (54usize, 69usize, 69usize),
        (59usize, 61usize, 61usize),
        (66usize, 68usize, 68usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![20usize, 27usize, 34usize, 41usize, 46usize, 54usize, 59usize, 66usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (20usize, 22usize),
        (27usize, 29usize),
        (34usize, 36usize),
        (41usize, 49usize),
        (46usize, 48usize),
        (54usize, 69usize),
        (59usize, 61usize),
        (66usize, 68usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "43", "44", "{\"x\":45}", "45", "{\"a\":46,\"x\":47}", "46", "47"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (20usize, 22usize, 22usize),
        (27usize, 29usize, 29usize),
        (34usize, 36usize, 36usize),
        (41usize, 49usize, 49usize),
        (46usize, 48usize, 48usize),
        (54usize, 69usize, 69usize),
        (59usize, 61usize, 61usize),
        (66usize, 68usize, 68usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![20usize, 27usize, 34usize, 41usize, 46usize, 54usize, 59usize, 66usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (20usize, 22usize),
        (27usize, 29usize),
        (34usize, 36usize),
        (41usize, 49usize),
        (46usize, 48usize),
        (54usize, 69usize),
        (59usize, 61usize),
        (66usize, 68usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "43", "44", "{\"x\":45}", "45", "{\"a\":46,\"x\":47}", "46", "47"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (20usize, 22usize, 22usize),
        (27usize, 29usize, 29usize),
        (34usize, 36usize, 36usize),
        (41usize, 49usize, 49usize),
        (54usize, 69usize, 69usize),
        (59usize, 61usize, 61usize),
        (66usize, 68usize, 68usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![20usize, 27usize, 34usize, 41usize, 54usize, 59usize, 66usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (20usize, 22usize),
        (27usize, 29usize),
        (34usize, 36usize),
        (41usize, 49usize),
        (54usize, 69usize),
        (59usize, 61usize),
        (66usize, 68usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "43", "44", "{\"x\":45}", "{\"a\":46,\"x\":47}", "46", "47"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (20usize, 22usize, 22usize),
        (27usize, 29usize, 29usize),
        (34usize, 36usize, 36usize),
        (41usize, 49usize, 49usize),
        (54usize, 69usize, 69usize),
        (59usize, 61usize, 61usize),
        (66usize, 68usize, 68usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![20usize, 27usize, 34usize, 41usize, 54usize, 59usize, 66usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (20usize, 22usize),
        (27usize, 29usize),
        (34usize, 36usize),
        (41usize, 49usize),
        (54usize, 69usize),
        (59usize, 61usize),
        (66usize, 68usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "43", "44", "{\"x\":45}", "{\"a\":46,\"x\":47}", "46", "47"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (20usize, 22usize, 22usize),
        (27usize, 29usize, 29usize),
        (34usize, 36usize, 36usize),
        (41usize, 49usize, 49usize),
        (54usize, 69usize, 69usize),
        (59usize, 61usize, 61usize),
        (66usize, 68usize, 68usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![20usize, 27usize, 34usize, 41usize, 54usize, 59usize, 66usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (20usize, 22usize),
        (27usize, 29usize),
        (34usize, 36usize),
        (41usize, 49usize),
        (54usize, 69usize),
        (59usize, 61usize),
        (66usize, 68usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_compressed_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "43", "44", "{\"x\":45}", "{\"a\":46,\"x\":47}", "46", "47"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (68usize, 70usize, 70usize),
        (93usize, 95usize, 95usize),
        (118usize, 120usize, 120usize),
        (143usize, 190usize, 190usize),
        (170usize, 172usize, 189usize),
        (213usize, 289usize, 302usize),
        (240usize, 242usize, 242usize),
        (269usize, 271usize, 288usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![68usize, 93usize, 118usize, 143usize, 170usize, 213usize, 240usize, 269usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (68usize, 70usize),
        (93usize, 95usize),
        (118usize, 120usize),
        (143usize, 190usize),
        (170usize, 172usize),
        (213usize, 289usize),
        (240usize, 242usize),
        (269usize, 271usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "43",
        "44",
        "{\n                    \"x\": 45\n                }",
        "45",
        "{\n                    \"a\": 46,\n                    \"x\": 47\n                }",
        "46",
        "47",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (68usize, 70usize, 70usize),
        (93usize, 95usize, 95usize),
        (118usize, 120usize, 120usize),
        (143usize, 190usize, 190usize),
        (170usize, 172usize, 189usize),
        (213usize, 289usize, 302usize),
        (240usize, 242usize, 242usize),
        (269usize, 271usize, 288usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![68usize, 93usize, 118usize, 143usize, 170usize, 213usize, 240usize, 269usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (68usize, 70usize),
        (93usize, 95usize),
        (118usize, 120usize),
        (143usize, 190usize),
        (170usize, 172usize),
        (213usize, 289usize),
        (240usize, 242usize),
        (269usize, 271usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "43",
        "44",
        "{\n                    \"x\": 45\n                }",
        "45",
        "{\n                    \"a\": 46,\n                    \"x\": 47\n                }",
        "46",
        "47",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (68usize, 70usize, 70usize),
        (93usize, 95usize, 95usize),
        (118usize, 120usize, 120usize),
        (143usize, 190usize, 190usize),
        (170usize, 172usize, 189usize),
        (213usize, 289usize, 302usize),
        (240usize, 242usize, 242usize),
        (269usize, 271usize, 288usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![68usize, 93usize, 118usize, 143usize, 170usize, 213usize, 240usize, 269usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (68usize, 70usize),
        (93usize, 95usize),
        (118usize, 120usize),
        (143usize, 190usize),
        (170usize, 172usize),
        (213usize, 289usize),
        (240usize, 242usize),
        (269usize, 271usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_all_subdocuments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a..* (descendant search for 'a' and then all subdocuments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "43",
        "44",
        "{\n                    \"x\": 45\n                }",
        "45",
        "{\n                    \"a\": 46,\n                    \"x\": 47\n                }",
        "46",
        "47",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (68usize, 70usize, 70usize),
        (93usize, 95usize, 95usize),
        (118usize, 120usize, 120usize),
        (143usize, 190usize, 190usize),
        (213usize, 289usize, 302usize),
        (240usize, 242usize, 242usize),
        (269usize, 271usize, 288usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![68usize, 93usize, 118usize, 143usize, 213usize, 240usize, 269usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (68usize, 70usize),
        (93usize, 95usize),
        (118usize, 120usize),
        (143usize, 190usize),
        (213usize, 289usize),
        (240usize, 242usize),
        (269usize, 271usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "43",
        "44",
        "{\n                    \"x\": 45\n                }",
        "{\n                    \"a\": 46,\n                    \"x\": 47\n                }",
        "46",
        "47",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (68usize, 70usize, 70usize),
        (93usize, 95usize, 95usize),
        (118usize, 120usize, 120usize),
        (143usize, 190usize, 190usize),
        (213usize, 289usize, 302usize),
        (240usize, 242usize, 242usize),
        (269usize, 271usize, 288usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![68usize, 93usize, 118usize, 143usize, 213usize, 240usize, 269usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (68usize, 70usize),
        (93usize, 95usize),
        (118usize, 120usize),
        (143usize, 190usize),
        (213usize, 289usize),
        (240usize, 242usize),
        (269usize, 271usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "43",
        "44",
        "{\n                    \"x\": 45\n                }",
        "{\n                    \"a\": 46,\n                    \"x\": 47\n                }",
        "46",
        "47",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (68usize, 70usize, 70usize),
        (93usize, 95usize, 95usize),
        (118usize, 120usize, 120usize),
        (143usize, 190usize, 190usize),
        (213usize, 289usize, 302usize),
        (240usize, 242usize, 242usize),
        (269usize, 271usize, 288usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![68usize, 93usize, 118usize, 143usize, 213usize, 240usize, 269usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (68usize, 70usize),
        (93usize, 95usize),
        (118usize, 120usize),
        (143usize, 190usize),
        (213usize, 289usize),
        (240usize, 242usize),
        (269usize, 271usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn dense_integer_atomic_leaves_without_lists_with_query_descendant_search_for_a_and_then_take_all_children_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document dense_atomic_leaves.toml running the query $..a.* (descendant search for 'a' and then take all children) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/dense_atomic_leaves.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "43",
        "44",
        "{\n                    \"x\": 45\n                }",
        "{\n                    \"a\": 46,\n                    \"x\": 47\n                }",
        "46",
        "47",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_any_item_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_compressed_with_query_select_the_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_any_item_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[*] (select any item (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_first_item_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $[0] (select the first item (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_array_root_with_query_select_the_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_array.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_array.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_compressed_with_query_select_the_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_document_with_query_select_the_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(4usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![4usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(4usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(4usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![4usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(4usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(4usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![4usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(4usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(4usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![4usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(4usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(4usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![4usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(4usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(4usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![4usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(4usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_compressed_with_query_select_the_empty_key_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $..[''] (select the empty key by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_json_keys_with_query_select_the_empty_key_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_key.toml running the query $[''] (select the empty key) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_key.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_child_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 2usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_compressed_with_query_select_the_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_child_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.* (select any child (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_any_descendant_there_are_none_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $..* (select any descendant (there are none)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_child_named_a_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $.a (select the child named 'a' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_empty_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query  (select the root (empty query)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 2usize, 3usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 2usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn empty_object_root_with_query_select_the_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document empty_object.toml running the query $ (select the root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/empty_object.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (151usize, 179usize, 179usize),
        (198usize, 226usize, 226usize),
        (341usize, 369usize, 369usize),
        (388usize, 416usize, 416usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![151usize, 198usize, 341usize, 388usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (151usize, 179usize),
        (198usize, 226usize),
        (341usize, 369usize),
        (388usize, 416usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (151usize, 179usize, 179usize),
        (198usize, 226usize, 226usize),
        (341usize, 369usize, 369usize),
        (388usize, 416usize, 416usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![151usize, 198usize, 341usize, 388usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (151usize, 179usize),
        (198usize, 226usize),
        (341usize, 369usize),
        (388usize, 416usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (151usize, 179usize, 179usize),
        (198usize, 226usize, 226usize),
        (341usize, 369usize, 369usize),
        (388usize, 416usize, 416usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![151usize, 198usize, 341usize, 388usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (151usize, 179usize),
        (198usize, 226usize),
        (341usize, 369usize),
        (388usize, 416usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_entities_then_url_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 179usize, 179usize), (341usize, 369usize, 369usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize, 341usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 179usize), (341usize, 369usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 179usize, 179usize), (341usize, 369usize, 369usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize, 341usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 179usize), (341usize, 369usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 179usize, 179usize), (341usize, 369usize, 369usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize, 341usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 179usize), (341usize, 369usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 179usize, 179usize), (341usize, 369usize, 369usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize, 341usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 179usize), (341usize, 369usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 179usize, 179usize), (341usize, 369usize, 369usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize, 341usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 179usize), (341usize, 369usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 179usize, 179usize), (341usize, 369usize, 369usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize, 341usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 179usize), (341usize, 369usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 54usize, 54usize),
        (90usize, 122usize, 122usize),
        (151usize, 179usize, 179usize),
        (198usize, 226usize, 226usize),
        (267usize, 295usize, 295usize),
        (341usize, 369usize, 369usize),
        (388usize, 416usize, 416usize),
        (426usize, 454usize, 454usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 90usize, 151usize, 198usize, 267usize, 341usize, 388usize, 426usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 54usize),
        (90usize, 122usize),
        (151usize, 179usize),
        (198usize, 226usize),
        (267usize, 295usize),
        (341usize, 369usize),
        (388usize, 416usize),
        (426usize, 454usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"http:\\/\\/www.roadshowrigoletto.com\\/\"",
        "\"http:\\/\\/www.thinkprogress.org\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 54usize, 54usize),
        (90usize, 122usize, 122usize),
        (151usize, 179usize, 179usize),
        (198usize, 226usize, 226usize),
        (267usize, 295usize, 295usize),
        (341usize, 369usize, 369usize),
        (388usize, 416usize, 416usize),
        (426usize, 454usize, 454usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 90usize, 151usize, 198usize, 267usize, 341usize, 388usize, 426usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 54usize),
        (90usize, 122usize),
        (151usize, 179usize),
        (198usize, 226usize),
        (267usize, 295usize),
        (341usize, 369usize),
        (388usize, 416usize),
        (426usize, 454usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"http:\\/\\/www.roadshowrigoletto.com\\/\"",
        "\"http:\\/\\/www.thinkprogress.org\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 54usize, 54usize),
        (90usize, 122usize, 122usize),
        (151usize, 179usize, 179usize),
        (198usize, 226usize, 226usize),
        (267usize, 295usize, 295usize),
        (341usize, 369usize, 369usize),
        (388usize, 416usize, 416usize),
        (426usize, 454usize, 454usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 90usize, 151usize, 198usize, 267usize, 341usize, 388usize, 426usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 54usize),
        (90usize, 122usize),
        (151usize, 179usize),
        (198usize, 226usize),
        (267usize, 295usize),
        (341usize, 369usize),
        (388usize, 416usize),
        (426usize, 454usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_descendant_search_for_url_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"http:\\/\\/www.roadshowrigoletto.com\\/\"",
        "\"http:\\/\\/www.thinkprogress.org\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(426usize, 454usize, 454usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![426usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(426usize, 454usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/blQy8JxViF\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(426usize, 454usize, 454usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![426usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(426usize, 454usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/blQy8JxViF\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(426usize, 454usize, 454usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![426usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(426usize, 454usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_compressed_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/blQy8JxViF\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (323usize, 351usize, 372usize),
        (473usize, 501usize, 522usize),
        (883usize, 911usize, 928usize),
        (1013usize, 1041usize, 1058usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![323usize, 473usize, 883usize, 1013usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (323usize, 351usize),
        (473usize, 501usize),
        (883usize, 911usize),
        (1013usize, 1041usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (323usize, 351usize, 372usize),
        (473usize, 501usize, 522usize),
        (883usize, 911usize, 928usize),
        (1013usize, 1041usize, 1058usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![323usize, 473usize, 883usize, 1013usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (323usize, 351usize),
        (473usize, 501usize),
        (883usize, 911usize),
        (1013usize, 1041usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (323usize, 351usize, 372usize),
        (473usize, 501usize, 522usize),
        (883usize, 911usize, 928usize),
        (1013usize, 1041usize, 1058usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![323usize, 473usize, 883usize, 1013usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (323usize, 351usize),
        (473usize, 501usize),
        (883usize, 911usize),
        (1013usize, 1041usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_entities_then_url_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..url (descendant entities then url) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(323usize, 351usize, 372usize), (883usize, 911usize, 928usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![323usize, 883usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(323usize, 351usize), (883usize, 911usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(323usize, 351usize, 372usize), (883usize, 911usize, 928usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![323usize, 883usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(323usize, 351usize), (883usize, 911usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(323usize, 351usize, 372usize), (883usize, 911usize, 928usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![323usize, 883usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(323usize, 351usize), (883usize, 911usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_direct_urls_arrays_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities.urls..url (descendant for url limited to direct urls arrays) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities.urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(323usize, 351usize, 372usize), (883usize, 911usize, 928usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![323usize, 883usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(323usize, 351usize), (883usize, 911usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(323usize, 351usize, 372usize), (883usize, 911usize, 928usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![323usize, 883usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(323usize, 351usize), (883usize, 911usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(323usize, 351usize, 372usize), (883usize, 911usize, 928usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![323usize, 883usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(323usize, 351usize), (883usize, 911usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_for_url_limited_to_urls_arrays_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..entities..urls..url (descendant for url limited to urls arrays) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..entities..urls..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/B6T1jj2hST\"", "\"https:\\/\\/t.co\\/B6T1jj2hST\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (45usize, 83usize, 92usize),
        (170usize, 202usize, 215usize),
        (323usize, 351usize, 372usize),
        (473usize, 501usize, 522usize),
        (672usize, 700usize, 721usize),
        (883usize, 911usize, 928usize),
        (1013usize, 1041usize, 1058usize),
        (1100usize, 1128usize, 1133usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![45usize, 170usize, 323usize, 473usize, 672usize, 883usize, 1013usize, 1100usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (45usize, 83usize),
        (170usize, 202usize),
        (323usize, 351usize),
        (473usize, 501usize),
        (672usize, 700usize),
        (883usize, 911usize),
        (1013usize, 1041usize),
        (1100usize, 1128usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"http:\\/\\/www.roadshowrigoletto.com\\/\"",
        "\"http:\\/\\/www.thinkprogress.org\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (45usize, 83usize, 92usize),
        (170usize, 202usize, 215usize),
        (323usize, 351usize, 372usize),
        (473usize, 501usize, 522usize),
        (672usize, 700usize, 721usize),
        (883usize, 911usize, 928usize),
        (1013usize, 1041usize, 1058usize),
        (1100usize, 1128usize, 1133usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![45usize, 170usize, 323usize, 473usize, 672usize, 883usize, 1013usize, 1100usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (45usize, 83usize),
        (170usize, 202usize),
        (323usize, 351usize),
        (473usize, 501usize),
        (672usize, 700usize),
        (883usize, 911usize),
        (1013usize, 1041usize),
        (1100usize, 1128usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"http:\\/\\/www.roadshowrigoletto.com\\/\"",
        "\"http:\\/\\/www.thinkprogress.org\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (45usize, 83usize, 92usize),
        (170usize, 202usize, 215usize),
        (323usize, 351usize, 372usize),
        (473usize, 501usize, 522usize),
        (672usize, 700usize, 721usize),
        (883usize, 911usize, 928usize),
        (1013usize, 1041usize, 1058usize),
        (1100usize, 1128usize, 1133usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 8u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![45usize, 170usize, 323usize, 473usize, 672usize, 883usize, 1013usize, 1100usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (45usize, 83usize),
        (170usize, 202usize),
        (323usize, 351usize),
        (473usize, 501usize),
        (672usize, 700usize),
        (883usize, 911usize),
        (1013usize, 1041usize),
        (1100usize, 1128usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_descendant_search_for_url_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $..url (descendant search for url) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"http:\\/\\/www.roadshowrigoletto.com\\/\"",
        "\"http:\\/\\/www.thinkprogress.org\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/B6T1jj2hST\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
        "\"https:\\/\\/t.co\\/blQy8JxViF\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(1100usize, 1128usize, 1133usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![1100usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(1100usize, 1128usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/blQy8JxViF\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(1100usize, 1128usize, 1133usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![1100usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(1100usize, 1128usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/blQy8JxViF\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(1100usize, 1128usize, 1133usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![1100usize,], "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(1100usize, 1128usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn extract_from_twitter_json_containing_urls_with_multiple_escaped_slashes_with_query_direct_path_to_the_top_level_url_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter_urls.toml running the query $[0].url (direct path to the top-level url) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/twitter_urls.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"https:\\/\\/t.co\\/blQy8JxViF\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(12usize, 14usize, 14usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![12usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(12usize, 14usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(12usize, 14usize, 14usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![12usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(12usize, 14usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(12usize, 14usize, 14usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![12usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(12usize, 14usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(19usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(19usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(19usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_compressed_with_query_descendant_search_for_b_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(28usize, 30usize, 30usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![28usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(28usize, 30usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(28usize, 30usize, 30usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![28usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(28usize, 30usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(28usize, 30usize, 30usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![28usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(28usize, 30usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_a_leading_quote_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..['\"b'] (descendant search for 'b' with a leading quote) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..['\"b']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(45usize, 47usize, 53usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![45usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(45usize, 47usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(45usize, 47usize, 53usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![45usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(45usize, 47usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(45usize, 47usize, 53usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![45usize,], "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(45usize, 47usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn label_b_and_b_with_escaped_quote_to_trick_naive_string_comparison_with_query_descendant_search_for_b_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document memchr_trap.toml running the query $..b (descendant search for 'b') with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/memchr_trap.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_claims_references_hash_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..claims..references..hash (descendant search for claims references hash) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..references..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 37736u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_claims_references_hash_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..claims..references..hash (descendant search for claims references hash) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..references..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 37736u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_claims_references_hash_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..claims..references..hash (descendant search for claims references hash) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..references..hash")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 37736u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_datavalue_value_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..datavalue..value..id (descendant search for datavalue value id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25093u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_datavalue_value_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..datavalue..value..id (descendant search for datavalue value id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25093u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_datavalue_value_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..datavalue..value..id (descendant search for datavalue value id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..datavalue..value..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25093u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_en_then_directly_for_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..en.value (descendant search for en, then directly for value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1753u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_en_then_directly_for_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..en.value (descendant search for en, then directly for value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1753u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_en_then_directly_for_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..en.value (descendant search for en, then directly for value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1753u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_en_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..en..value (descendant search for en value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2360u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_en_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..en..value (descendant search for en value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2360u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_en_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..en..value (descendant search for en value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2360u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_mainsnak_datavalue_value_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..mainsnak..datavalue..value..id (descendant search for mainsnak datavalue value id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12958u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_mainsnak_datavalue_value_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..mainsnak..datavalue..value..id (descendant search for mainsnak datavalue value id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12958u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_mainsnak_datavalue_value_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..mainsnak..datavalue..value..id (descendant search for mainsnak datavalue value id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12958u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_mainsnak_datavalue_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..mainsnak..datavalue..value (descendant search for mainsnak datavalue value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 26115u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_mainsnak_datavalue_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..mainsnak..datavalue..value (descendant search for mainsnak datavalue value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 26115u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_mainsnak_datavalue_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..mainsnak..datavalue..value (descendant search for mainsnak datavalue value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 26115u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_value_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue..value..id (descendant search for references snaks datavalue value id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_value_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue..value..id (descendant search for references snaks datavalue value id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_value_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue..value..id (descendant search for references snaks datavalue value id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue..value (descendant search for references snaks datavalue value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue..value (descendant search for references snaks datavalue value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue..value (descendant search for references snaks datavalue value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue (descendant search for references snaks datavalue) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue (descendant search for references snaks datavalue) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_references_snaks_datavalue_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..references..snaks..datavalue (descendant search for references snaks datavalue) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_snaks_datavalue_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..snaks..datavalue..value (descendant search for snaks datavalue value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_snaks_datavalue_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..snaks..datavalue..value (descendant search for snaks datavalue value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_snaks_datavalue_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..snaks..datavalue..value (descendant search for snaks datavalue value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..datavalue..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_snaks_then_any_descendant_and_its_id_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..snaks..*.id (descendant search for snaks, then any descendant and its id child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_snaks_then_any_descendant_and_its_id_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..snaks..*.id (descendant search for snaks, then any descendant and its id child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_descendant_search_for_snaks_then_any_descendant_and_its_id_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..snaks..*.id (descendant search for snaks, then any descendant and its id child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..*.id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_select_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 970442u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_select_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 970442u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_compressed_with_query_select_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_person.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 970442u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_claims_references_hash_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..claims..references..hash (descendant search for claims references hash) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..references..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 37736u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_claims_references_hash_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..claims..references..hash (descendant search for claims references hash) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..references..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 37736u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_claims_references_hash_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..claims..references..hash (descendant search for claims references hash) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..references..hash")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 37736u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_datavalue_value_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..datavalue..value..id (descendant search for datavalue value id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25093u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_datavalue_value_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..datavalue..value..id (descendant search for datavalue value id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25093u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_datavalue_value_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..datavalue..value..id (descendant search for datavalue value id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..datavalue..value..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25093u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_en_then_directly_for_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..en.value (descendant search for en, then directly for value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1753u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_en_then_directly_for_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..en.value (descendant search for en, then directly for value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1753u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_en_then_directly_for_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..en.value (descendant search for en, then directly for value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1753u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_en_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..en..value (descendant search for en value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2360u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_en_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..en..value (descendant search for en value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2360u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_en_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..en..value (descendant search for en value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2360u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_mainsnak_datavalue_value_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..mainsnak..datavalue..value..id (descendant search for mainsnak datavalue value id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12958u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_mainsnak_datavalue_value_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..mainsnak..datavalue..value..id (descendant search for mainsnak datavalue value id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12958u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_mainsnak_datavalue_value_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..mainsnak..datavalue..value..id (descendant search for mainsnak datavalue value id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 12958u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_mainsnak_datavalue_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..mainsnak..datavalue..value (descendant search for mainsnak datavalue value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 26115u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_mainsnak_datavalue_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..mainsnak..datavalue..value (descendant search for mainsnak datavalue value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 26115u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_mainsnak_datavalue_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..mainsnak..datavalue..value (descendant search for mainsnak datavalue value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..mainsnak..datavalue..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 26115u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_value_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue..value..id (descendant search for references snaks datavalue value id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_value_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue..value..id (descendant search for references snaks datavalue value id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_value_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue..value..id (descendant search for references snaks datavalue value id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue..value (descendant search for references snaks datavalue value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue..value (descendant search for references snaks datavalue value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue..value (descendant search for references snaks datavalue value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue (descendant search for references snaks datavalue) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue (descendant search for references snaks datavalue) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_references_snaks_datavalue_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..references..snaks..datavalue (descendant search for references snaks datavalue) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..references..snaks..datavalue")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_snaks_datavalue_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..snaks..datavalue..value (descendant search for snaks datavalue value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_snaks_datavalue_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..snaks..datavalue..value (descendant search for snaks datavalue value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..datavalue..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_snaks_datavalue_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..snaks..datavalue..value (descendant search for snaks datavalue value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..datavalue..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 25118u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_snaks_then_any_descendant_and_its_id_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..snaks..*.id (descendant search for snaks, then any descendant and its id child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_snaks_then_any_descendant_and_its_id_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..snaks..*.id (descendant search for snaks, then any descendant and its id child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_descendant_search_for_snaks_then_any_descendant_and_its_id_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..snaks..*.id (descendant search for snaks, then any descendant and its id child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..snaks..*.id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11113u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_select_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 970442u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_select_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 970442u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_person_with_query_select_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_person.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_person.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 970442u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..* (all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1702482u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..* (all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1702482u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..* (all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1702482u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_any_node_and_then_its_id_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..*.id (descendant search for any node and then its 'id' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 98805u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_any_node_and_then_its_id_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..*.id (descendant search for any node and then its 'id' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 98805u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_any_node_and_then_its_id_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..*.id (descendant search for any node and then its 'id' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.id")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 98805u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_claims_mainsnak_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..claims..mainsnak..value (descendant search for claims mainsnak value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..mainsnak..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 59112u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_claims_mainsnak_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..claims..mainsnak..value (descendant search for claims mainsnak value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..mainsnak..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 59112u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_claims_mainsnak_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..claims..mainsnak..value (descendant search for claims mainsnak value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..mainsnak..value")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 59112u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_en_then_its_value_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..en.value (descendant search for en, then its 'value' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9452u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_en_then_its_value_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..en.value (descendant search for en, then its 'value' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9452u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_en_then_its_value_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..en.value (descendant search for en, then its 'value' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9452u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_en_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..en..value (descendant search for en value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 13634u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_en_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..en..value (descendant search for en value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 13634u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_compressed_with_query_descendant_search_for_en_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_profession.toml running the query $..en..value (descendant search for en value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 13634u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..* (all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1702482u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..* (all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1702482u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..* (all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1702482u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_any_node_and_then_its_id_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..*.id (descendant search for any node and then its 'id' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 98805u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_any_node_and_then_its_id_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..*.id (descendant search for any node and then its 'id' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 98805u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_any_node_and_then_its_id_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..*.id (descendant search for any node and then its 'id' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 98805u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_claims_mainsnak_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..claims..mainsnak..value (descendant search for claims mainsnak value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..mainsnak..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 59112u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_claims_mainsnak_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..claims..mainsnak..value (descendant search for claims mainsnak value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..mainsnak..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 59112u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_claims_mainsnak_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..claims..mainsnak..value (descendant search for claims mainsnak value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..claims..mainsnak..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 59112u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_en_then_its_value_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..en.value (descendant search for en, then its 'value' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9452u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_en_then_its_value_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..en.value (descendant search for en, then its 'value' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9452u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_en_then_its_value_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..en.value (descendant search for en, then its 'value' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 9452u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_en_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..en..value (descendant search for en value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 13634u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_en_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..en..value (descendant search for en value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 13634u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_profession_with_query_descendant_search_for_en_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_profession.toml running the query $..en..value (descendant search for en value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_profession.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 13634u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..* (all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 922519u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..* (all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 922519u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..* (all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 922519u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_any_node_and_then_its_value_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..*.value (descendant search for any node and then its 'value' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 132188u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_any_node_and_then_its_value_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..*.value (descendant search for any node and then its 'value' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 132188u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_any_node_and_then_its_value_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..*.value (descendant search for any node and then its 'value' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.value")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 132188u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_en_and_then_its_value_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..en.value (descendant search for en, and then its 'value' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1760u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_en_and_then_its_value_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..en.value (descendant search for en, and then its 'value' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1760u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_en_and_then_its_value_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..en.value (descendant search for en, and then its 'value' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1760u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_en_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..en..value (descendant search for en value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4504u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_en_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..en..value (descendant search for en value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4504u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_en_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..en..value (descendant search for en value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4504u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_qualifiers_datavalue_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..qualifiers..datavalue..id (descendant search for qualifiers datavalue id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..qualifiers..datavalue..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18219u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_qualifiers_datavalue_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..qualifiers..datavalue..id (descendant search for qualifiers datavalue id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..qualifiers..datavalue..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18219u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_qualifiers_datavalue_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..qualifiers..datavalue..id (descendant search for qualifiers datavalue id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..qualifiers..datavalue..id")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18219u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_the_fifth_array_element_of_any_node_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..*[5] (descendant search for the fifth array element of any node) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[5]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2511u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_the_fifth_array_element_of_any_node_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..*[5] (descendant search for the fifth array element of any node) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[5]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2511u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_descendant_search_for_the_fifth_array_element_of_any_node_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..*[5] (descendant search for the fifth array element of any node) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[5]")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2511u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21204179usize,], "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21204179usize, 21204221usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"8841ebd7f526f7e3be79708694452b2260d5a33d\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21204179usize,], "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21204179usize, 21204221usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"8841ebd7f526f7e3be79708694452b2260d5a33d\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21204179usize,], "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21204179usize, 21204221usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_compressed_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"8841ebd7f526f7e3be79708694452b2260d5a33d\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..* (all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 922519u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..* (all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 922519u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..* (all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 922519u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_any_node_and_then_its_value_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..*.value (descendant search for any node and then its 'value' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 132188u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_any_node_and_then_its_value_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..*.value (descendant search for any node and then its 'value' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 132188u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_any_node_and_then_its_value_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..*.value (descendant search for any node and then its 'value' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 132188u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_en_and_then_its_value_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..en.value (descendant search for en, and then its 'value' child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1760u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_en_and_then_its_value_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..en.value (descendant search for en, and then its 'value' child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1760u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_en_and_then_its_value_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..en.value (descendant search for en, and then its 'value' child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en.value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1760u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_en_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..en..value (descendant search for en value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4504u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_en_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..en..value (descendant search for en value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4504u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_en_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..en..value (descendant search for en value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..en..value")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4504u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_qualifiers_datavalue_id_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..qualifiers..datavalue..id (descendant search for qualifiers datavalue id) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..qualifiers..datavalue..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18219u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_qualifiers_datavalue_id_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..qualifiers..datavalue..id (descendant search for qualifiers datavalue id) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..qualifiers..datavalue..id")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18219u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_qualifiers_datavalue_id_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..qualifiers..datavalue..id (descendant search for qualifiers datavalue id) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..qualifiers..datavalue..id")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18219u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_the_fifth_array_element_of_any_node_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..*[5] (descendant search for the fifth array element of any node) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[5]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2511u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_the_fifth_array_element_of_any_node_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..*[5] (descendant search for the fifth array element of any node) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[5]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2511u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_descendant_search_for_the_fifth_array_element_of_any_node_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..*[5] (descendant search for the fifth array element of any node) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[5]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2511u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![22639035usize,], "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(22639035usize, 22639077usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"8841ebd7f526f7e3be79708694452b2260d5a33d\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![22639035usize,], "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(22639035usize, 22639077usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"8841ebd7f526f7e3be79708694452b2260d5a33d\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![22639035usize,], "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(22639035usize, 22639077usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn large_wikidata_dump_properties_with_query_path_to_p7103_claims_p31_references_snaks_p4656_hash_with_descendants_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document wikidata_properties.toml running the query $..P7103.claims.P31..references..snaks.P4656..hash (path to P7103 claims P31 references snaks P4656 hash with descendants) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..P7103.claims.P31..references..snaks.P4656..hash")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/wikidata_properties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"8841ebd7f526f7e3be79708694452b2260d5a33d\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 8usize, 8usize),
        (9usize, 17usize, 17usize),
        (18usize, 20usize, 20usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 9usize, 18usize,], "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (9usize, 17usize), (18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "{\"b\":43}", "44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 8usize, 8usize),
        (9usize, 17usize, 17usize),
        (18usize, 20usize, 20usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 9usize, 18usize,], "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (9usize, 17usize), (18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "{\"b\":43}", "44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 8usize, 8usize),
        (9usize, 17usize, 17usize),
        (18usize, 20usize, 20usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 9usize, 18usize,], "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (9usize, 17usize), (18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_compressed_with_query_select_all_elements_on_the_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "{\"b\":43}", "44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (15usize, 17usize, 17usize),
        (23usize, 44usize, 44usize),
        (50usize, 52usize, 55usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![15usize, 23usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(15usize, 17usize), (23usize, 44usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "{\n      \"b\": 43\n    }", "44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (15usize, 17usize, 17usize),
        (23usize, 44usize, 44usize),
        (50usize, 52usize, 55usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![15usize, 23usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(15usize, 17usize), (23usize, 44usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "{\n      \"b\": 43\n    }", "44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (15usize, 17usize, 17usize),
        (23usize, 44usize, 44usize),
        (50usize, 52usize, 55usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![15usize, 23usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(15usize, 17usize), (23usize, 44usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_mixed_atomic_integers_and_objects_with_query_select_all_elements_on_the_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document heterogenous_list.toml running the query $.a.* (select all elements on the list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/heterogenous_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "{\n      \"b\": 43\n    }", "44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (1usize, 2usize, 2usize),
        (3usize, 4usize, 4usize),
        (5usize, 11usize, 11usize),
        (6usize, 8usize, 8usize),
        (9usize, 10usize, 10usize),
        (12usize, 15usize, 15usize),
        (13usize, 14usize, 14usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![1usize, 3usize, 5usize, 6usize, 9usize, 12usize, 13usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (1usize, 2usize),
        (3usize, 4usize),
        (5usize, 11usize),
        (6usize, 8usize),
        (9usize, 10usize),
        (12usize, 15usize),
        (13usize, 14usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "[{},4]", "{}", "4", "[5]", "5"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (1usize, 2usize, 2usize),
        (3usize, 4usize, 4usize),
        (5usize, 11usize, 11usize),
        (6usize, 8usize, 8usize),
        (9usize, 10usize, 10usize),
        (12usize, 15usize, 15usize),
        (13usize, 14usize, 14usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![1usize, 3usize, 5usize, 6usize, 9usize, 12usize, 13usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (1usize, 2usize),
        (3usize, 4usize),
        (5usize, 11usize),
        (6usize, 8usize),
        (9usize, 10usize),
        (12usize, 15usize),
        (13usize, 14usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "[{},4]", "{}", "4", "[5]", "5"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (1usize, 2usize, 2usize),
        (3usize, 4usize, 4usize),
        (5usize, 11usize, 11usize),
        (6usize, 8usize, 8usize),
        (9usize, 10usize, 10usize),
        (12usize, 15usize, 15usize),
        (13usize, 14usize, 14usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![1usize, 3usize, 5usize, 6usize, 9usize, 12usize, 13usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (1usize, 2usize),
        (3usize, 4usize),
        (5usize, 11usize),
        (6usize, 8usize),
        (9usize, 10usize),
        (12usize, 15usize),
        (13usize, 14usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "[{},4]", "{}", "4", "[5]", "5"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (4usize, 5usize, 5usize),
        (9usize, 10usize, 10usize),
        (14usize, 33usize, 33usize),
        (20usize, 22usize, 22usize),
        (28usize, 29usize, 32usize),
        (37usize, 48usize, 49usize),
        (43usize, 44usize, 47usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![4usize, 9usize, 14usize, 20usize, 28usize, 37usize, 43usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (4usize, 5usize),
        (9usize, 10usize),
        (14usize, 33usize),
        (20usize, 22usize),
        (28usize, 29usize),
        (37usize, 48usize),
        (43usize, 44usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "[\n    {},\n    4\n  ]", "{}", "4", "[\n    5\n  ]", "5"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (4usize, 5usize, 5usize),
        (9usize, 10usize, 10usize),
        (14usize, 33usize, 33usize),
        (20usize, 22usize, 22usize),
        (28usize, 29usize, 32usize),
        (37usize, 48usize, 49usize),
        (43usize, 44usize, 47usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![4usize, 9usize, 14usize, 20usize, 28usize, 37usize, 43usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (4usize, 5usize),
        (9usize, 10usize),
        (14usize, 33usize),
        (20usize, 22usize),
        (28usize, 29usize),
        (37usize, 48usize),
        (43usize, 44usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "[\n    {},\n    4\n  ]", "{}", "4", "[\n    5\n  ]", "5"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (4usize, 5usize, 5usize),
        (9usize, 10usize, 10usize),
        (14usize, 33usize, 33usize),
        (20usize, 22usize, 22usize),
        (28usize, 29usize, 32usize),
        (37usize, 48usize, 49usize),
        (43usize, 44usize, 47usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![4usize, 9usize, 14usize, 20usize, 28usize, 37usize, 43usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (4usize, 5usize),
        (9usize, 10usize),
        (14usize, 33usize),
        (20usize, 22usize),
        (28usize, 29usize),
        (37usize, 48usize),
        (43usize, 44usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn list_with_nested_sublists_to_stress_output_ordering_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document ordered_list.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/ordered_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["1", "2", "[\n    {},\n    4\n  ]", "{}", "4", "[\n    5\n  ]", "5"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(355usize, 357usize, 357usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![355usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(355usize, 357usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(355usize, 357usize, 357usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![355usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(355usize, 357usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(355usize, 357usize, 357usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![355usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(355usize, 357usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_extremely_long_label_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(10usize, 115usize, 115usize), (125usize, 127usize, 127usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![10usize, 125usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(10usize, 115usize), (125usize, 127usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "{\"please note the important whitespaces after the upcoming comma (pretend indentation is really big)\":42}",
        "43",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(10usize, 115usize, 115usize), (125usize, 127usize, 127usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![10usize, 125usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(10usize, 115usize), (125usize, 127usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "{\"please note the important whitespaces after the upcoming comma (pretend indentation is really big)\":42}",
        "43",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(10usize, 115usize, 115usize), (125usize, 127usize, 127usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![10usize, 125usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(10usize, 115usize), (125usize, 127usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_compressed_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "{\"please note the important whitespaces after the upcoming comma (pretend indentation is really big)\":42}",
        "43",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(428usize, 430usize, 431usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![428usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(428usize, 430usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(428usize, 430usize, 431usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![428usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(428usize, 430usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(428usize, 430usize, 431usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![428usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(428usize, 430usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_extremely_long_label_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249'] (select the extremely long label) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery :: parse ("$..['very long label to search for, like, extremely long, so that the colon occurs really far away from the start of the needle match, which triggers some interesting behavior and might break the head skipping module like in #249']") ? ;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 128usize, 128usize), (194usize, 196usize, 196usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize, 194usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 128usize), (194usize, 196usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["{\n    \"please note the important whitespaces after the upcoming comma (pretend indentation is really big)\": 42\n  }" , "43" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 128usize, 128usize), (194usize, 196usize, 196usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize, 194usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 128usize), (194usize, 196usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["{\n    \"please note the important whitespaces after the upcoming comma (pretend indentation is really big)\": 42\n  }" , "43" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 128usize, 128usize), (194usize, 196usize, 196usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize, 194usize,], "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 128usize), (194usize, 196usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn long_labels_to_search_with_head_skipping_issue_249_with_query_select_the_label_starting_exactly_at_block_boundary_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document head_skip_long.toml running the query $..target (select the label starting exactly at block boundary) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..target")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/head_skip_long.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["{\n    \"please note the important whitespaces after the upcoming comma (pretend indentation is really big)\": 42\n  }" , "43" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(525usize, 527usize, 527usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![525usize,], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(525usize, 527usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(525usize, 527usize, 527usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![525usize,], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(525usize, 527usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(525usize, 527usize, 527usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![525usize,], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(525usize, 527usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_compressed_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(611usize, 613usize, 622usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![611usize,], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(611usize, 613usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(611usize, 613usize, 622usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![611usize,], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(611usize, 613usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(611usize, 613usize, 622usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![611usize,], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(611usize, 613usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_one_actual_backslash_which_is_two_backslashes_in_the_query_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\'] (select label with one actual backslash, which is two backslashes in the query) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn members_with_escaped_double_quotes_and_braces_and_brackets_with_query_select_label_with_two_actual_backslashes_four_backslashes_in_the_query_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document escapes.toml running the query $..a..b..['label\\\\\\\\'] (select label with two actual backslashes (four backslashes in the query), which does not exist) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b..['label\\\\\\\\']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/escapes.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(18usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(18usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(18usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 7usize, 7usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 7usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 7usize, 7usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 7usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 7usize, 7usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 7usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 7usize, 7usize),
        (12usize, 22usize, 22usize),
        (13usize, 21usize, 21usize),
        (18usize, 20usize, 20usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize, 12usize, 13usize, 18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 7usize),
        (12usize, 22usize),
        (13usize, 21usize),
        (18usize, 20usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "[{\"b\":43}]", "{\"b\":43}", "43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 7usize, 7usize),
        (12usize, 22usize, 22usize),
        (13usize, 21usize, 21usize),
        (18usize, 20usize, 20usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize, 12usize, 13usize, 18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 7usize),
        (12usize, 22usize),
        (13usize, 21usize),
        (18usize, 20usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "[{\"b\":43}]", "{\"b\":43}", "43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 7usize, 7usize),
        (12usize, 22usize, 22usize),
        (13usize, 21usize, 21usize),
        (18usize, 20usize, 20usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize, 12usize, 13usize, 18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 7usize),
        (12usize, 22usize),
        (13usize, 21usize),
        (18usize, 20usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_all_decsendants_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42", "[{\"b\":43}]", "{\"b\":43}", "43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"b\":43}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"b\":43}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"b\":43}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"b\":43}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"b\":43}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 21usize, 21usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 21usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_first_element_of_b_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"b\":43}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(18usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(18usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(18usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![18usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(18usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_nested_b_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_compressed_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(53usize, 55usize, 64usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(53usize, 55usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(53usize, 55usize, 64usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(53usize, 55usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(53usize, 55usize, 64usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(53usize, 55usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_b_on_at_least_one_level_of_nesting_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..*..b (look for 'b' on at least one level of nesting) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_look_for_descendants_of_an_atomic_value_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a..b (look for descendants of an atomic value) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_a_number_that_is_a_child_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..a (select a number that is a child) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 13usize, 13usize),
        (24usize, 71usize, 72usize),
        (34usize, 65usize, 70usize),
        (53usize, 55usize, 64usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize, 24usize, 34usize, 53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 13usize),
        (24usize, 71usize),
        (34usize, 65usize),
        (53usize, 55usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "[\n        {\n            \"b\": 43\n        }\n    ]",
        "{\n            \"b\": 43\n        }",
        "43",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 13usize, 13usize),
        (24usize, 71usize, 72usize),
        (34usize, 65usize, 70usize),
        (53usize, 55usize, 64usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize, 24usize, 34usize, 53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 13usize),
        (24usize, 71usize),
        (34usize, 65usize),
        (53usize, 55usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "[\n        {\n            \"b\": 43\n        }\n    ]",
        "{\n            \"b\": 43\n        }",
        "43",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 13usize, 13usize),
        (24usize, 71usize, 72usize),
        (34usize, 65usize, 70usize),
        (53usize, 55usize, 64usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize, 24usize, 34usize, 53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 13usize),
        (24usize, 71usize),
        (34usize, 65usize),
        (53usize, 55usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_all_decsendants_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..* (select all decsendants) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "42",
        "[\n        {\n            \"b\": 43\n        }\n    ]",
        "{\n            \"b\": 43\n        }",
        "43",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(34usize, 65usize, 70usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![34usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(34usize, 65usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\n            \"b\": 43\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(34usize, 65usize, 70usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![34usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(34usize, 65usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\n            \"b\": 43\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(34usize, 65usize, 70usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![34usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(34usize, 65usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_first_item_from_list_descendants_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $..[0] (select first item from list descendants) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\n            \"b\": 43\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(34usize, 65usize, 70usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![34usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(34usize, 65usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\n            \"b\": 43\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(34usize, 65usize, 70usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![34usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(34usize, 65usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\n            \"b\": 43\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(34usize, 65usize, 70usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![34usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(34usize, 65usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_first_element_of_b_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0] (select the first element of 'b') with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\n            \"b\": 43\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(53usize, 55usize, 64usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(53usize, 55usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(53usize, 55usize, 64usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(53usize, 55usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(53usize, 55usize, 64usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![53usize,], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(53usize, 55usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_nested_b_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[0].b (select the nested 'b' directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[0].b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["43"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_b_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $.b[1] (select the second element of 'b' (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.b[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn nested_atomic_member_with_query_select_the_second_element_of_the_root_which_is_not_an_array_so_result_should_be_empty_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_descendant.toml running the query $[1] (select the second element of the root (which is not an array, so result should be empty)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_descendant.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(31usize, 33usize, 33usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![31usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(31usize, 33usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(31usize, 33usize, 33usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![31usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(31usize, 33usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(31usize, 33usize, 33usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![31usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(31usize, 33usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(31usize, 33usize, 33usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![31usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(31usize, 33usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(31usize, 33usize, 33usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![31usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(31usize, 33usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(31usize, 33usize, 33usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![31usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(31usize, 33usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 35usize, 35usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"c\":{\"d\":[42,43,44],\"b\":45}}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 35usize, 35usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"c\":{\"d\":[42,43,44],\"b\":45}}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 35usize, 35usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"c\":{\"d\":[42,43,44],\"b\":45}}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(23usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![23usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(23usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(23usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![23usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(23usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(23usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![23usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(23usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(23usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![23usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(23usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(23usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![23usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(23usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(23usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![23usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(23usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_compressed_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(176usize, 178usize, 191usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![176usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(176usize, 178usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(176usize, 178usize, 191usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![176usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(176usize, 178usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(176usize, 178usize, 191usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![176usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(176usize, 178usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_a_object_and_then_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a..b (select the 'a' object and then the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(176usize, 178usize, 191usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![176usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(176usize, 178usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(176usize, 178usize, 191usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![176usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(176usize, 178usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(176usize, 178usize, 191usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![176usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(176usize, 178usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_atomic_integer_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..b (select the atomic integer by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..b")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["45"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 202usize, 207usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 202usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["{\n            \"c\": {\n                \"d\": [\n                    42,\n                    43,\n                    44\n                ],\n                \"b\": 45\n            }\n        }" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 202usize, 207usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 202usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["{\n            \"c\": {\n                \"d\": [\n                    42,\n                    43,\n                    44\n                ],\n                \"b\": 45\n            }\n        }" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 202usize, 207usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 202usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_first_and_only_element_of_the_a_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0] (select the first and only element of the 'a' list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["{\n            \"c\": {\n                \"d\": [\n                    42,\n                    43,\n                    44\n                ],\n                \"b\": 45\n            }\n        }" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 0u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_fourth_element_of_the_deeply_nested_list_which_does_not_exist_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[3] (select the fourth element of the deeply nested list (which does not exist)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[3]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(133usize, 135usize, 152usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![133usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(133usize, 135usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(133usize, 135usize, 152usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![133usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(133usize, 135usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(133usize, 135usize, 152usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![133usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(133usize, 135usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_and_last_element_of_the_deeply_nested_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $.a[0].c.d[2] (select the third and last element of the deeply nested list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[0].c.d[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(133usize, 135usize, 152usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![133usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(133usize, 135usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(133usize, 135usize, 152usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![133usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(133usize, 135usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(133usize, 135usize, 152usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![133usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(133usize, 135usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_a_list_of_integers_followed_by_an_atomic_integer_member_with_query_select_the_third_element_of_each_list_only_the_deeply_nested_one_has_a_third_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document atomic_after_list.toml running the query $..*[2] (select the third element of each list (only the deeply nested one has a third element)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[2]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/atomic_after_list.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["44"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["17"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["17"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 16usize, 16usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 16usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["17"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(7usize, 9usize, 9usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![7usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(7usize, 9usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(7usize, 9usize, 9usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![7usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(7usize, 9usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(7usize, 9usize, 9usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![7usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(7usize, 9usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_compressed_with_query_select_x_with_quote_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(26usize, 28usize, 29usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![26usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(26usize, 28usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["17"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(26usize, 28usize, 29usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![26usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(26usize, 28usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["17"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(26usize, 28usize, 29usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![26usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(26usize, 28usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['x'] (select 'x' directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["17"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 15usize, 15usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 15usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 15usize, 15usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 15usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(13usize, 15usize, 15usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![13usize,], "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(13usize, 15usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn object_with_two_labels_x_and_x_with_a_preceding_escaped_double_quote_with_query_select_x_with_quote_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document quote_escape.toml running the query $['\"x'] (select 'x' with quote directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$['\"x']")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/quote_escape.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(19usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(19usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(19usize, 20usize, 20usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_0_1_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (15usize, 21usize, 21usize),
        (22usize, 28usize, 28usize),
        (29usize, 35usize, 35usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![15usize, 22usize, 29usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(15usize, 21usize), (22usize, 28usize), (29usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[],0]", "[[],0]", "[[],0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (15usize, 21usize, 21usize),
        (22usize, 28usize, 28usize),
        (29usize, 35usize, 35usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![15usize, 22usize, 29usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(15usize, 21usize), (22usize, 28usize), (29usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[],0]", "[[],0]", "[[],0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (15usize, 21usize, 21usize),
        (22usize, 28usize, 28usize),
        (29usize, 35usize, 35usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![15usize, 22usize, 29usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(15usize, 21usize), (22usize, 28usize), (29usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[],0]", "[[],0]", "[[],0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(2usize, 5usize, 5usize), (11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![2usize, 11usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(2usize, 5usize), (11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(2usize, 5usize, 5usize), (11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![2usize, 11usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(2usize, 5usize), (11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(2usize, 5usize, 5usize), (11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![2usize, 11usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(2usize, 5usize), (11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (1usize, 6usize, 6usize),
        (2usize, 5usize, 5usize),
        (3usize, 4usize, 4usize),
        (7usize, 9usize, 9usize),
        (10usize, 37usize, 37usize),
        (11usize, 13usize, 13usize),
        (14usize, 36usize, 36usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (19usize, 20usize, 20usize),
        (22usize, 28usize, 28usize),
        (23usize, 25usize, 25usize),
        (26usize, 27usize, 27usize),
        (29usize, 35usize, 35usize),
        (30usize, 32usize, 32usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 16u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            1usize, 2usize, 3usize, 7usize, 10usize, 11usize, 14usize, 15usize, 16usize, 19usize, 22usize, 23usize,
            26usize, 29usize, 30usize, 33usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (1usize, 6usize),
        (2usize, 5usize),
        (3usize, 4usize),
        (7usize, 9usize),
        (10usize, 37usize),
        (11usize, 13usize),
        (14usize, 36usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (19usize, 20usize),
        (22usize, 28usize),
        (23usize, 25usize),
        (26usize, 27usize),
        (29usize, 35usize),
        (30usize, 32usize),
        (33usize, 34usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[[0]]",
        "[0]",
        "0",
        "[]",
        "[[],[[[],0],[[],0],[[],0]]]",
        "[]",
        "[[[],0],[[],0],[[],0]]",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (1usize, 6usize, 6usize),
        (2usize, 5usize, 5usize),
        (3usize, 4usize, 4usize),
        (7usize, 9usize, 9usize),
        (10usize, 37usize, 37usize),
        (11usize, 13usize, 13usize),
        (14usize, 36usize, 36usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (19usize, 20usize, 20usize),
        (22usize, 28usize, 28usize),
        (23usize, 25usize, 25usize),
        (26usize, 27usize, 27usize),
        (29usize, 35usize, 35usize),
        (30usize, 32usize, 32usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 16u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            1usize, 2usize, 3usize, 7usize, 10usize, 11usize, 14usize, 15usize, 16usize, 19usize, 22usize, 23usize,
            26usize, 29usize, 30usize, 33usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (1usize, 6usize),
        (2usize, 5usize),
        (3usize, 4usize),
        (7usize, 9usize),
        (10usize, 37usize),
        (11usize, 13usize),
        (14usize, 36usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (19usize, 20usize),
        (22usize, 28usize),
        (23usize, 25usize),
        (26usize, 27usize),
        (29usize, 35usize),
        (30usize, 32usize),
        (33usize, 34usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[[0]]",
        "[0]",
        "0",
        "[]",
        "[[],[[[],0],[[],0],[[],0]]]",
        "[]",
        "[[[],0],[[],0],[[],0]]",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (1usize, 6usize, 6usize),
        (2usize, 5usize, 5usize),
        (3usize, 4usize, 4usize),
        (7usize, 9usize, 9usize),
        (10usize, 37usize, 37usize),
        (11usize, 13usize, 13usize),
        (14usize, 36usize, 36usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (19usize, 20usize, 20usize),
        (22usize, 28usize, 28usize),
        (23usize, 25usize, 25usize),
        (26usize, 27usize, 27usize),
        (29usize, 35usize, 35usize),
        (30usize, 32usize, 32usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 16u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            1usize, 2usize, 3usize, 7usize, 10usize, 11usize, 14usize, 15usize, 16usize, 19usize, 22usize, 23usize,
            26usize, 29usize, 30usize, 33usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (1usize, 6usize),
        (2usize, 5usize),
        (3usize, 4usize),
        (7usize, 9usize),
        (10usize, 37usize),
        (11usize, 13usize),
        (14usize, 36usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (19usize, 20usize),
        (22usize, 28usize),
        (23usize, 25usize),
        (26usize, 27usize),
        (29usize, 35usize),
        (30usize, 32usize),
        (33usize, 34usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_all_non_root_nodes_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[[0]]",
        "[0]",
        "0",
        "[]",
        "[[],[[[],0],[[],0],[[],0]]]",
        "[]",
        "[[[],0],[[],0],[[],0]]",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(2usize, 5usize, 5usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![2usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(2usize, 5usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(2usize, 5usize, 5usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![2usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(2usize, 5usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(2usize, 5usize, 5usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![2usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(2usize, 5usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (2usize, 5usize, 5usize),
        (3usize, 4usize, 4usize),
        (11usize, 13usize, 13usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![2usize, 3usize, 11usize, 15usize, 16usize, 23usize, 30usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (2usize, 5usize),
        (3usize, 4usize),
        (11usize, 13usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "0", "[]", "[[],0]", "[]", "[]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (2usize, 5usize, 5usize),
        (3usize, 4usize, 4usize),
        (11usize, 13usize, 13usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![2usize, 3usize, 11usize, 15usize, 16usize, 23usize, 30usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (2usize, 5usize),
        (3usize, 4usize),
        (11usize, 13usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "0", "[]", "[[],0]", "[]", "[]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (2usize, 5usize, 5usize),
        (3usize, 4usize, 4usize),
        (11usize, 13usize, 13usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![2usize, 3usize, 11usize, 15usize, 16usize, 23usize, 30usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (2usize, 5usize),
        (3usize, 4usize),
        (11usize, 13usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "0", "[]", "[[],0]", "[]", "[]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(11usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(11usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(1usize, 6usize, 6usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![1usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(1usize, 6usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[0]]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(1usize, 6usize, 6usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![1usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(1usize, 6usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[0]]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(1usize, 6usize, 6usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![1usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(1usize, 6usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_first_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[0]]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 13usize, 13usize),
        (14usize, 36usize, 36usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (19usize, 20usize, 20usize),
        (22usize, 28usize, 28usize),
        (23usize, 25usize, 25usize),
        (26usize, 27usize, 27usize),
        (29usize, 35usize, 35usize),
        (30usize, 32usize, 32usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![11usize, 14usize, 15usize, 16usize, 19usize, 22usize, 23usize, 26usize, 29usize, 30usize, 33usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 13usize),
        (14usize, 36usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (19usize, 20usize),
        (22usize, 28usize),
        (23usize, 25usize),
        (26usize, 27usize),
        (29usize, 35usize),
        (30usize, 32usize),
        (33usize, 34usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[]",
        "[[[],0],[[],0],[[],0]]",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 13usize, 13usize),
        (14usize, 36usize, 36usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (19usize, 20usize, 20usize),
        (22usize, 28usize, 28usize),
        (23usize, 25usize, 25usize),
        (26usize, 27usize, 27usize),
        (29usize, 35usize, 35usize),
        (30usize, 32usize, 32usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![11usize, 14usize, 15usize, 16usize, 19usize, 22usize, 23usize, 26usize, 29usize, 30usize, 33usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 13usize),
        (14usize, 36usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (19usize, 20usize),
        (22usize, 28usize),
        (23usize, 25usize),
        (26usize, 27usize),
        (29usize, 35usize),
        (30usize, 32usize),
        (33usize, 34usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[]",
        "[[[],0],[[],0],[[],0]]",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 13usize, 13usize),
        (14usize, 36usize, 36usize),
        (15usize, 21usize, 21usize),
        (16usize, 18usize, 18usize),
        (19usize, 20usize, 20usize),
        (22usize, 28usize, 28usize),
        (23usize, 25usize, 25usize),
        (26usize, 27usize, 27usize),
        (29usize, 35usize, 35usize),
        (30usize, 32usize, 32usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![11usize, 14usize, 15usize, 16usize, 19usize, 22usize, 23usize, 26usize, 29usize, 30usize, 33usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 13usize),
        (14usize, 36usize),
        (15usize, 21usize),
        (16usize, 18usize),
        (19usize, 20usize),
        (22usize, 28usize),
        (23usize, 25usize),
        (26usize, 27usize),
        (29usize, 35usize),
        (30usize, 32usize),
        (33usize, 34usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[]",
        "[[[],0],[[],0],[[],0]]",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
        "[[],0]",
        "[]",
        "0",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (19usize, 20usize, 20usize),
        (26usize, 27usize, 27usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize, 26usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize), (26usize, 27usize), (33usize, 34usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (19usize, 20usize, 20usize),
        (26usize, 27usize, 27usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize, 26usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize), (26usize, 27usize), (33usize, 34usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (19usize, 20usize, 20usize),
        (26usize, 27usize, 27usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize, 26usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize), (26usize, 27usize), (33usize, 34usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(22usize, 28usize, 28usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![22usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(22usize, 28usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[],0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(22usize, 28usize, 28usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![22usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(22usize, 28usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[],0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(22usize, 28usize, 28usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![22usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(22usize, 28usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[],0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (19usize, 20usize, 20usize),
        (26usize, 27usize, 27usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize, 26usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize), (26usize, 27usize), (33usize, 34usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (19usize, 20usize, 20usize),
        (26usize, 27usize, 27usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize, 26usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize), (26usize, 27usize), (33usize, 34usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (19usize, 20usize, 20usize),
        (26usize, 27usize, 27usize),
        (33usize, 34usize, 34usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![19usize, 26usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(19usize, 20usize), (26usize, 27usize), (33usize, 34usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 36usize, 36usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 36usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[[],0],[[],0],[[],0]]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 36usize, 36usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 36usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[[],0],[[],0],[[],0]]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(14usize, 36usize, 36usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![14usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(14usize, 36usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_compressed_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[[[],0],[[],0],[[],0]]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(113usize, 114usize, 127usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(113usize, 114usize, 127usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(113usize, 114usize, 127usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_0_1_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1][0][1] (direct path 2-1-0-1) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1][0][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (75usize, 128usize, 128usize),
        (142usize, 195usize, 195usize),
        (209usize, 262usize, 271usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![75usize, 142usize, 209usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(75usize, 128usize), (142usize, 195usize), (209usize, 262usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[\n                [],\n                0\n            ]",
        "[\n                [],\n                0\n            ]",
        "[\n                [],\n                0\n            ]",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (75usize, 128usize, 128usize),
        (142usize, 195usize, 195usize),
        (209usize, 262usize, 271usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![75usize, 142usize, 209usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(75usize, 128usize), (142usize, 195usize), (209usize, 262usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[\n                [],\n                0\n            ]",
        "[\n                [],\n                0\n            ]",
        "[\n                [],\n                0\n            ]",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (75usize, 128usize, 128usize),
        (142usize, 195usize, 195usize),
        (209usize, 262usize, 271usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![75usize, 142usize, 209usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(75usize, 128usize), (142usize, 195usize), (209usize, 262usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_direct_path_2_1_and_then_any_child_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1].* (direct path 2-1 and then any child) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[\n                [],\n                0\n            ]",
        "[\n                [],\n                0\n            ]",
        "[\n                [],\n                0\n            ]",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(16usize, 19usize, 24usize), (49usize, 51usize, 51usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![16usize, 49usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(16usize, 19usize), (49usize, 51usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(16usize, 19usize, 24usize), (49usize, 51usize, 51usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![16usize, 49usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(16usize, 19usize), (49usize, 51usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(16usize, 19usize, 24usize), (49usize, 51usize, 51usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![16usize, 49usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(16usize, 19usize), (49usize, 51usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_nodes_at_depth_one_and_then_their_first_list_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $.*[0] (select all nodes at depth one and then their first list element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 25usize, 25usize),
        (16usize, 19usize, 24usize),
        (17usize, 18usize, 18usize),
        (31usize, 33usize, 33usize),
        (39usize, 278usize, 279usize),
        (49usize, 51usize, 51usize),
        (61usize, 272usize, 277usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (113usize, 114usize, 127usize),
        (142usize, 195usize, 195usize),
        (160usize, 162usize, 162usize),
        (180usize, 181usize, 194usize),
        (209usize, 262usize, 271usize),
        (227usize, 229usize, 229usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 16u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            6usize, 16usize, 17usize, 31usize, 39usize, 49usize, 61usize, 75usize, 93usize, 113usize, 142usize,
            160usize, 180usize, 209usize, 227usize, 247usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (6usize, 25usize),
        (16usize, 19usize),
        (17usize, 18usize),
        (31usize, 33usize),
        (39usize, 278usize),
        (49usize, 51usize),
        (61usize, 272usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (113usize, 114usize),
        (142usize, 195usize),
        (160usize, 162usize),
        (180usize, 181usize),
        (209usize, 262usize),
        (227usize, 229usize),
        (247usize, 248usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[\n        [0]\n    ]" , "[0]" , "0" , "[]" , "[\n        [],\n        [\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]\n    ]" , "[]" , "[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 25usize, 25usize),
        (16usize, 19usize, 24usize),
        (17usize, 18usize, 18usize),
        (31usize, 33usize, 33usize),
        (39usize, 278usize, 279usize),
        (49usize, 51usize, 51usize),
        (61usize, 272usize, 277usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (113usize, 114usize, 127usize),
        (142usize, 195usize, 195usize),
        (160usize, 162usize, 162usize),
        (180usize, 181usize, 194usize),
        (209usize, 262usize, 271usize),
        (227usize, 229usize, 229usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 16u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            6usize, 16usize, 17usize, 31usize, 39usize, 49usize, 61usize, 75usize, 93usize, 113usize, 142usize,
            160usize, 180usize, 209usize, 227usize, 247usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (6usize, 25usize),
        (16usize, 19usize),
        (17usize, 18usize),
        (31usize, 33usize),
        (39usize, 278usize),
        (49usize, 51usize),
        (61usize, 272usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (113usize, 114usize),
        (142usize, 195usize),
        (160usize, 162usize),
        (180usize, 181usize),
        (209usize, 262usize),
        (227usize, 229usize),
        (247usize, 248usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[\n        [0]\n    ]" , "[0]" , "0" , "[]" , "[\n        [],\n        [\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]\n    ]" , "[]" , "[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 25usize, 25usize),
        (16usize, 19usize, 24usize),
        (17usize, 18usize, 18usize),
        (31usize, 33usize, 33usize),
        (39usize, 278usize, 279usize),
        (49usize, 51usize, 51usize),
        (61usize, 272usize, 277usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (113usize, 114usize, 127usize),
        (142usize, 195usize, 195usize),
        (160usize, 162usize, 162usize),
        (180usize, 181usize, 194usize),
        (209usize, 262usize, 271usize),
        (227usize, 229usize, 229usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 16u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            6usize, 16usize, 17usize, 31usize, 39usize, 49usize, 61usize, 75usize, 93usize, 113usize, 142usize,
            160usize, 180usize, 209usize, 227usize, 247usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (6usize, 25usize),
        (16usize, 19usize),
        (17usize, 18usize),
        (31usize, 33usize),
        (39usize, 278usize),
        (49usize, 51usize),
        (61usize, 272usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (113usize, 114usize),
        (142usize, 195usize),
        (160usize, 162usize),
        (180usize, 181usize),
        (209usize, 262usize),
        (227usize, 229usize),
        (247usize, 248usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_all_non_root_nodes_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..* (select all non-root nodes) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[\n        [0]\n    ]" , "[0]" , "0" , "[]" , "[\n        [],\n        [\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]\n    ]" , "[]" , "[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(16usize, 19usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![16usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(16usize, 19usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(16usize, 19usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![16usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(16usize, 19usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(16usize, 19usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![16usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(16usize, 19usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_and_then_all_its_children_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0].* (select the first element and then all its children) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0].*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 19usize, 24usize),
        (17usize, 18usize, 18usize),
        (49usize, 51usize, 51usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (160usize, 162usize, 162usize),
        (227usize, 229usize, 229usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 17usize, 49usize, 75usize, 93usize, 160usize, 227usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 19usize),
        (17usize, 18usize),
        (49usize, 51usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (160usize, 162usize),
        (227usize, 229usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[0]",
        "0",
        "[]",
        "[\n                [],\n                0\n            ]",
        "[]",
        "[]",
        "[]",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 19usize, 24usize),
        (17usize, 18usize, 18usize),
        (49usize, 51usize, 51usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (160usize, 162usize, 162usize),
        (227usize, 229usize, 229usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 17usize, 49usize, 75usize, 93usize, 160usize, 227usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 19usize),
        (17usize, 18usize),
        (49usize, 51usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (160usize, 162usize),
        (227usize, 229usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[0]",
        "0",
        "[]",
        "[\n                [],\n                0\n            ]",
        "[]",
        "[]",
        "[]",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (16usize, 19usize, 24usize),
        (17usize, 18usize, 18usize),
        (49usize, 51usize, 51usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (160usize, 162usize, 162usize),
        (227usize, 229usize, 229usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 7u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![16usize, 17usize, 49usize, 75usize, 93usize, 160usize, 227usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (16usize, 19usize),
        (17usize, 18usize),
        (49usize, 51usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (160usize, 162usize),
        (227usize, 229usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_every_nested_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $..*[0] (select the first element of every nested list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "[0]",
        "0",
        "[]",
        "[\n                [],\n                0\n            ]",
        "[]",
        "[]",
        "[]",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(49usize, 51usize, 51usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![49usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(49usize, 51usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(49usize, 51usize, 51usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![49usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(49usize, 51usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(49usize, 51usize, 51usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![49usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(49usize, 51usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_of_the_long_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][0] (select the first element of the long list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        [0]\n    ]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        [0]\n    ]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 25usize, 25usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_first_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[0] (select the first element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        [0]\n    ]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (49usize, 51usize, 51usize),
        (61usize, 272usize, 277usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (113usize, 114usize, 127usize),
        (142usize, 195usize, 195usize),
        (160usize, 162usize, 162usize),
        (180usize, 181usize, 194usize),
        (209usize, 262usize, 271usize),
        (227usize, 229usize, 229usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![49usize, 61usize, 75usize, 93usize, 113usize, 142usize, 160usize, 180usize, 209usize, 227usize, 247usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (49usize, 51usize),
        (61usize, 272usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (113usize, 114usize),
        (142usize, 195usize),
        (160usize, 162usize),
        (180usize, 181usize),
        (209usize, 262usize),
        (227usize, 229usize),
        (247usize, 248usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[]" , "[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (49usize, 51usize, 51usize),
        (61usize, 272usize, 277usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (113usize, 114usize, 127usize),
        (142usize, 195usize, 195usize),
        (160usize, 162usize, 162usize),
        (180usize, 181usize, 194usize),
        (209usize, 262usize, 271usize),
        (227usize, 229usize, 229usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![49usize, 61usize, 75usize, 93usize, 113usize, 142usize, 160usize, 180usize, 209usize, 227usize, 247usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (49usize, 51usize),
        (61usize, 272usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (113usize, 114usize),
        (142usize, 195usize),
        (160usize, 162usize),
        (180usize, 181usize),
        (209usize, 262usize),
        (227usize, 229usize),
        (247usize, 248usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[]" , "[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (49usize, 51usize, 51usize),
        (61usize, 272usize, 277usize),
        (75usize, 128usize, 128usize),
        (93usize, 95usize, 95usize),
        (113usize, 114usize, 127usize),
        (142usize, 195usize, 195usize),
        (160usize, 162usize, 162usize),
        (180usize, 181usize, 194usize),
        (209usize, 262usize, 271usize),
        (227usize, 229usize, 229usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 11u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![49usize, 61usize, 75usize, 93usize, 113usize, 142usize, 160usize, 180usize, 209usize, 227usize, 247usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (49usize, 51usize),
        (61usize, 272usize),
        (75usize, 128usize),
        (93usize, 95usize),
        (113usize, 114usize),
        (142usize, 195usize),
        (160usize, 162usize),
        (180usize, 181usize),
        (209usize, 262usize),
        (227usize, 229usize),
        (247usize, 248usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_and_then_its_every_subdocument_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2]..* (select the long list and then its every subdocument) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2]..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[]" , "[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" , "[\n                [],\n                0\n            ]" , "[]" , "0" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (113usize, 114usize, 127usize),
        (180usize, 181usize, 194usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize, 180usize, 247usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize), (180usize, 181usize), (247usize, 248usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (113usize, 114usize, 127usize),
        (180usize, 181usize, 194usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize, 180usize, 247usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize), (180usize, 181usize), (247usize, 248usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (113usize, 114usize, 127usize),
        (180usize, 181usize, 194usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize, 180usize, 247usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize), (180usize, 181usize), (247usize, 248usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_go_two_levels_down_and_select_the_second_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*.*[1] (select the long list, then go two levels down and select the second element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*.*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(142usize, 195usize, 195usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![142usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(142usize, 195usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n                [],\n                0\n            ]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(142usize, 195usize, 195usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![142usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(142usize, 195usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n                [],\n                0\n            ]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(142usize, 195usize, 195usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![142usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(142usize, 195usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_long_list_then_in_each_sublist_select_the_second_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2].*[1] (select the long list, then in each sublist select the second element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2].*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n                [],\n                0\n            ]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (113usize, 114usize, 127usize),
        (180usize, 181usize, 194usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize, 180usize, 247usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize), (180usize, 181usize), (247usize, 248usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (113usize, 114usize, 127usize),
        (180usize, 181usize, 194usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize, 180usize, 247usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize), (180usize, 181usize), (247usize, 248usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (113usize, 114usize, 127usize),
        (180usize, 181usize, 194usize),
        (247usize, 248usize, 261usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![113usize, 180usize, 247usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(113usize, 114usize), (180usize, 181usize), (247usize, 248usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_path_2_1_then_in_any_subtree_select_the_second_list_element_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1]..*[1] (select the path 2-1, then in any subtree select the second list element) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]..*[1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "0", "0"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(61usize, 272usize, 277usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![61usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(61usize, 272usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(61usize, 272usize, 277usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![61usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(61usize, 272usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(61usize, 272usize, 277usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![61usize,], "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(61usize, 272usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn only_lists_and_integers_nested_in_each_other_with_query_select_the_second_element_of_the_long_list_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document lists.toml running the query $[2][1] (select the second element of the long list) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$[2][1]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/lists.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected : Vec < & str > = vec ! ["[\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ],\n            [\n                [],\n                0\n            ]\n        ]" ,] ;
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize), (25usize, 27usize, 27usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize, 25usize,], "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize), (25usize, 27usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\"", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize), (25usize, 27usize, 27usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize, 25usize,], "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize), (25usize, 27usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\"", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(8usize, 16usize, 16usize), (25usize, 27usize, 27usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![8usize, 25usize,], "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(8usize, 16usize), (25usize, 27usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\"", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(12usize, 20usize, 20usize), (33usize, 35usize, 36usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![12usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(12usize, 20usize), (33usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\"", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(12usize, 20usize, 20usize), (33usize, 35usize, 36usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![12usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(12usize, 20usize), (33usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\"", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(12usize, 20usize, 20usize), (33usize, 35usize, 36usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![12usize, 33usize,], "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(12usize, 20usize), (33usize, 35usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_inline_input_structure_with_query_select_all_subdocuments_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_inline.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/test_template_inline.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"value1\"", "42"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_input_file_structure_compressed_with_query_select_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_large.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/test_template_large.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1000000u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_input_file_structure_compressed_with_query_select_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_large.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/test_template_large.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1000000u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_input_file_structure_compressed_with_query_select_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/test_template_large.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/test_template_large.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1000000u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_input_file_structure_with_query_select_all_subdocuments_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_large.toml running the query $..* (select all subdocuments) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/test_template_large.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1000000u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_input_file_structure_with_query_select_all_subdocuments_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_large.toml running the query $..* (select all subdocuments) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/test_template_large.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1000000u64, "result != expected");
    Ok(())
}
#[test]
fn short_description_of_the_input_file_structure_with_query_select_all_subdocuments_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document test_template_large.toml running the query $..* (select all subdocuments) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/test_template_large.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1000000u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(169usize, 185usize, 185usize), (211usize, 227usize, 227usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![169usize, 211usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(169usize, 185usize), (211usize, 227usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"0123-4567-8888\"", "\"0123-4567-8910\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(169usize, 185usize, 185usize), (211usize, 227usize, 227usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![169usize, 211usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(169usize, 185usize), (211usize, 227usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"0123-4567-8888\"", "\"0123-4567-8910\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(169usize, 185usize, 185usize), (211usize, 227usize, 227usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![169usize, 211usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(169usize, 185usize), (211usize, 227usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_descendant_search_for_number_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"0123-4567-8888\"", "\"0123-4567-8910\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 159usize, 159usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 159usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 159usize, 159usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 159usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(151usize, 159usize, 159usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![151usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(151usize, 159usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(143usize, 186usize, 186usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![143usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(143usize, 186usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(143usize, 186usize, 186usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![143usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(143usize, 186usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(143usize, 186usize, 186usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![143usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(143usize, 186usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_compressed_with_query_select_first_number_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(271usize, 287usize, 296usize), (359usize, 375usize, 384usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![271usize, 359usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(271usize, 287usize), (359usize, 375usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"0123-4567-8888\"", "\"0123-4567-8910\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(271usize, 287usize, 296usize), (359usize, 375usize, 384usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![271usize, 359usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(271usize, 287usize), (359usize, 375usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"0123-4567-8888\"", "\"0123-4567-8910\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(271usize, 287usize, 296usize), (359usize, 375usize, 384usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![271usize, 359usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(271usize, 287usize), (359usize, 375usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_descendant_search_for_number_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $..number (descendant search for 'number') with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"0123-4567-8888\"", "\"0123-4567-8910\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(239usize, 247usize, 247usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![239usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(239usize, 247usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(239usize, 247usize, 247usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![239usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(239usize, 247usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(239usize, 247usize, 247usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![239usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(239usize, 247usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_exact_path_with_name_and_index_selectors_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0].type (select exact path with name and index selectors) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0].type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(217usize, 297usize, 297usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![217usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(217usize, 297usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> =
        vec!["{\n            \"type\": \"iPhone\",\n            \"number\": \"0123-4567-8888\"\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(217usize, 297usize, 297usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![217usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(217usize, 297usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> =
        vec!["{\n            \"type\": \"iPhone\",\n            \"number\": \"0123-4567-8888\"\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(217usize, 297usize, 297usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![217usize,], "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(217usize, 297usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn short_json_with_objects_and_lists_given_as_an_example_on_jsonpath_com_with_query_select_first_number_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example.toml running the query $.phoneNumbers[0] (select first number directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.phoneNumbers[0]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> =
        vec!["{\n            \"type\": \"iPhone\",\n            \"number\": \"0123-4567-8888\"\n        }"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 8usize, 8usize), (15usize, 17usize, 17usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 15usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (15usize, 17usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 8usize, 8usize), (15usize, 17usize, 17usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 15usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (15usize, 17usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 8usize, 8usize), (15usize, 17usize, 17usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 15usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (15usize, 17usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 9usize, 9usize),
        (14usize, 18usize, 18usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize, 14usize, 23usize, 30usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 9usize),
        (14usize, 18usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[{}]", "[[]]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 9usize, 9usize),
        (14usize, 18usize, 18usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize, 14usize, 23usize, 30usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 9usize),
        (14usize, 18usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[{}]", "[[]]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 9usize, 9usize),
        (14usize, 18usize, 18usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize, 14usize, 23usize, 30usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 9usize),
        (14usize, 18usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[{}]", "[[]]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 8usize, 8usize), (15usize, 17usize, 17usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 15usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (15usize, 17usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 8usize, 8usize), (15usize, 17usize, 17usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 15usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (15usize, 17usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(6usize, 8usize, 8usize), (15usize, 17usize, 17usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 15usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 8usize), (15usize, 17usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 9usize, 9usize),
        (6usize, 8usize, 8usize),
        (14usize, 18usize, 18usize),
        (15usize, 17usize, 17usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![5usize, 6usize, 14usize, 15usize, 23usize, 30usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 9usize),
        (6usize, 8usize),
        (14usize, 18usize),
        (15usize, 17usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[{}]", "{}", "[[]]", "[]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 9usize, 9usize),
        (6usize, 8usize, 8usize),
        (14usize, 18usize, 18usize),
        (15usize, 17usize, 17usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![5usize, 6usize, 14usize, 15usize, 23usize, 30usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 9usize),
        (6usize, 8usize),
        (14usize, 18usize),
        (15usize, 17usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[{}]", "{}", "[[]]", "[]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (5usize, 9usize, 9usize),
        (6usize, 8usize, 8usize),
        (14usize, 18usize, 18usize),
        (15usize, 17usize, 17usize),
        (23usize, 25usize, 25usize),
        (30usize, 32usize, 32usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![5usize, 6usize, 14usize, 15usize, 23usize, 30usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5usize, 9usize),
        (6usize, 8usize),
        (14usize, 18usize),
        (15usize, 17usize),
        (23usize, 25usize),
        (30usize, 32usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_compressed_with_query_select_all_nodes_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[{}]", "{}", "[[]]", "[]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 23usize, 28usize), (50usize, 52usize, 57usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 23usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 23usize, 28usize), (50usize, 52usize, 57usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 23usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 23usize, 28usize), (50usize, 52usize, 57usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 23usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_at_least_2_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..*.* (select all nodes at depth at least 2) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 29usize, 29usize),
        (40usize, 58usize, 58usize),
        (69usize, 71usize, 71usize),
        (82usize, 84usize, 85usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize, 40usize, 69usize, 82usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 29usize),
        (40usize, 58usize),
        (69usize, 71usize),
        (82usize, 84usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        {}\n    ]", "[\n        []\n    ]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 29usize, 29usize),
        (40usize, 58usize, 58usize),
        (69usize, 71usize, 71usize),
        (82usize, 84usize, 85usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize, 40usize, 69usize, 82usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 29usize),
        (40usize, 58usize),
        (69usize, 71usize),
        (82usize, 84usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        {}\n    ]", "[\n        []\n    ]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 29usize, 29usize),
        (40usize, 58usize, 58usize),
        (69usize, 71usize, 71usize),
        (82usize, 84usize, 85usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![11usize, 40usize, 69usize, 82usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 29usize),
        (40usize, 58usize),
        (69usize, 71usize),
        (82usize, 84usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_1_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.* (select all nodes at depth exactly 1) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        {}\n    ]", "[\n        []\n    ]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 23usize, 28usize), (50usize, 52usize, 57usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 23usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 23usize, 28usize), (50usize, 52usize, 57usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 23usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(21usize, 23usize, 28usize), (50usize, 52usize, 57usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 2u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![21usize, 50usize,], "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(21usize, 23usize), (50usize, 52usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_at_depth_exactly_2_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $.*.* (select all nodes at depth exactly 2) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.*.*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{}", "[]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 29usize, 29usize),
        (21usize, 23usize, 28usize),
        (40usize, 58usize, 58usize),
        (50usize, 52usize, 57usize),
        (69usize, 71usize, 71usize),
        (82usize, 84usize, 85usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![11usize, 21usize, 40usize, 50usize, 69usize, 82usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 29usize),
        (21usize, 23usize),
        (40usize, 58usize),
        (50usize, 52usize),
        (69usize, 71usize),
        (82usize, 84usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        {}\n    ]", "{}", "[\n        []\n    ]", "[]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 29usize, 29usize),
        (21usize, 23usize, 28usize),
        (40usize, 58usize, 58usize),
        (50usize, 52usize, 57usize),
        (69usize, 71usize, 71usize),
        (82usize, 84usize, 85usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![11usize, 21usize, 40usize, 50usize, 69usize, 82usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 29usize),
        (21usize, 23usize),
        (40usize, 58usize),
        (50usize, 52usize),
        (69usize, 71usize),
        (82usize, 84usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        {}\n    ]", "{}", "[\n        []\n    ]", "[]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (11usize, 29usize, 29usize),
        (21usize, 23usize, 28usize),
        (40usize, 58usize, 58usize),
        (50usize, 52usize, 57usize),
        (69usize, 71usize, 71usize),
        (82usize, 84usize, 85usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 6u64, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![11usize, 21usize, 40usize, 50usize, 69usize, 82usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (11usize, 29usize),
        (21usize, 23usize),
        (40usize, 58usize),
        (50usize, 52usize),
        (69usize, 71usize),
        (82usize, 84usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn single_element_lists_empty_lists_and_empty_objects_with_query_select_all_nodes_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document singletons_and_empties.toml running the query $..* (select all nodes) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..*")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/singletons_and_empties.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[\n        {}\n    ]", "{}", "[\n        []\n    ]", "[]", "[]", "{}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (178usize, 194usize, 194usize),
        (220usize, 236usize, 236usize),
        (426usize, 442usize, 442usize),
        (468usize, 484usize, 484usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![178usize, 220usize, 426usize, 468usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (178usize, 194usize),
        (220usize, 236usize),
        (426usize, 442usize),
        (468usize, 484usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"0123-4567-8888\"",
        "\"0123-4567-8910\"",
        "\"0123-4567-9999\"",
        "\"0123-4567-9012\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (178usize, 194usize, 194usize),
        (220usize, 236usize, 236usize),
        (426usize, 442usize, 442usize),
        (468usize, 484usize, 484usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![178usize, 220usize, 426usize, 468usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (178usize, 194usize),
        (220usize, 236usize),
        (426usize, 442usize),
        (468usize, 484usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"0123-4567-8888\"",
        "\"0123-4567-8910\"",
        "\"0123-4567-9999\"",
        "\"0123-4567-9012\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (178usize, 194usize, 194usize),
        (220usize, 236usize, 236usize),
        (426usize, 442usize, 442usize),
        (468usize, 484usize, 484usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![178usize, 220usize, 426usize, 468usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (178usize, 194usize),
        (220usize, 236usize),
        (426usize, 442usize),
        (468usize, 484usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"0123-4567-8888\"",
        "\"0123-4567-8910\"",
        "\"0123-4567-9999\"",
        "\"0123-4567-9012\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (160usize, 168usize, 168usize),
        (204usize, 210usize, 210usize),
        (408usize, 416usize, 416usize),
        (452usize, 458usize, 458usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![160usize, 204usize, 408usize, 452usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (160usize, 168usize),
        (204usize, 210usize),
        (408usize, 416usize),
        (452usize, 458usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\"", "\"home\"", "\"iPhone\"", "\"home\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (160usize, 168usize, 168usize),
        (204usize, 210usize, 210usize),
        (408usize, 416usize, 416usize),
        (452usize, 458usize, 458usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![160usize, 204usize, 408usize, 452usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (160usize, 168usize),
        (204usize, 210usize),
        (408usize, 416usize),
        (452usize, 458usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file =
        fs::File::open("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\"", "\"home\"", "\"iPhone\"", "\"home\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (160usize, 168usize, 168usize),
        (204usize, 210usize, 210usize),
        (408usize, 416usize, 416usize),
        (452usize, 458usize, 458usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![160usize, 204usize, 408usize, 452usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (160usize, 168usize),
        (204usize, 210usize),
        (408usize, 416usize),
        (452usize, 458usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_compressed_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json =
        fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\"", "\"home\"", "\"iPhone\"", "\"home\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (334usize, 350usize, 363usize),
        (438usize, 454usize, 467usize),
        (936usize, 952usize, 973usize),
        (1072usize, 1088usize, 1109usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![334usize, 438usize, 936usize, 1072usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (334usize, 350usize),
        (438usize, 454usize),
        (936usize, 952usize),
        (1072usize, 1088usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"0123-4567-8888\"",
        "\"0123-4567-8910\"",
        "\"0123-4567-9999\"",
        "\"0123-4567-9012\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (334usize, 350usize, 363usize),
        (438usize, 454usize, 467usize),
        (936usize, 952usize, 973usize),
        (1072usize, 1088usize, 1109usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![334usize, 438usize, 936usize, 1072usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (334usize, 350usize),
        (438usize, 454usize),
        (936usize, 952usize),
        (1072usize, 1088usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"0123-4567-8888\"",
        "\"0123-4567-8910\"",
        "\"0123-4567-9999\"",
        "\"0123-4567-9012\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (334usize, 350usize, 363usize),
        (438usize, 454usize, 467usize),
        (936usize, 952usize, 973usize),
        (1072usize, 1088usize, 1109usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![334usize, 438usize, 936usize, 1072usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (334usize, 350usize),
        (438usize, 454usize),
        (936usize, 952usize),
        (1072usize, 1088usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_phone_number_number_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..phoneNumber..number (descendant search for person phoneNumber number) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..phoneNumber..number")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec![
        "\"0123-4567-8888\"",
        "\"0123-4567-8910\"",
        "\"0123-4567-9999\"",
        "\"0123-4567-9012\"",
    ];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (298usize, 306usize, 306usize),
        (404usize, 410usize, 410usize),
        (892usize, 900usize, 900usize),
        (1030usize, 1036usize, 1036usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![298usize, 404usize, 892usize, 1030usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (298usize, 306usize),
        (404usize, 410usize),
        (892usize, 900usize),
        (1030usize, 1036usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\"", "\"home\"", "\"iPhone\"", "\"home\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (298usize, 306usize, 306usize),
        (404usize, 410usize, 410usize),
        (892usize, 900usize, 900usize),
        (1030usize, 1036usize, 1036usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![298usize, 404usize, 892usize, 1030usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (298usize, 306usize),
        (404usize, 410usize),
        (892usize, 900usize),
        (1030usize, 1036usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\"", "\"home\"", "\"iPhone\"", "\"home\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (298usize, 306usize, 306usize),
        (404usize, 410usize, 410usize),
        (892usize, 900usize, 900usize),
        (1030usize, 1036usize, 1036usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 4u64, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![298usize, 404usize, 892usize, 1030usize,],
        "result != expected"
    );
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (298usize, 306usize),
        (404usize, 410usize),
        (892usize, 900usize),
        (1030usize, 1036usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn the_example_on_jsonpath_com_extended_with_another_nested_person_object_with_query_descendant_search_for_person_then_any_node_then_type_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document jsonpath_com_example_extended.toml running the query $..person..*..type (descendant search for person, then any node, then type) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..person..*..type")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/jsonpath_com_example_extended.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["\"iPhone\"", "\"home\"", "\"iPhone\"", "\"home\""];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            3488usize,
            9836usize,
            12718usize,
            52574usize,
            64603usize,
            77997usize,
            119307usize,
            121918usize,
            201073usize,
            212698usize,
            215343usize,
            241826usize,
            288269usize,
            310030usize,
            312972usize,
            445431usize,
            454460usize,
            464576usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (3488usize, 3628usize),
        (9836usize, 10004usize),
        (12718usize, 12882usize),
        (52574usize, 52738usize),
        (64603usize, 64737usize),
        (77997usize, 78134usize),
        (119307usize, 119445usize),
        (121918usize, 122066usize),
        (201073usize, 201238usize),
        (212698usize, 212847usize),
        (215343usize, 215493usize),
        (241826usize, 241966usize),
        (288269usize, 288425usize),
        (310030usize, 310168usize),
        (312972usize, 313108usize),
        (445431usize, 445606usize),
        (454460usize, 454594usize),
        (464576usize, 464738usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            3488usize,
            9836usize,
            12718usize,
            52574usize,
            64603usize,
            77997usize,
            119307usize,
            121918usize,
            201073usize,
            212698usize,
            215343usize,
            241826usize,
            288269usize,
            310030usize,
            312972usize,
            445431usize,
            454460usize,
            464576usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (3488usize, 3628usize),
        (9836usize, 10004usize),
        (12718usize, 12882usize),
        (52574usize, 52738usize),
        (64603usize, 64737usize),
        (77997usize, 78134usize),
        (119307usize, 119445usize),
        (121918usize, 122066usize),
        (201073usize, 201238usize),
        (212698usize, 212847usize),
        (215343usize, 215493usize),
        (241826usize, 241966usize),
        (288269usize, 288425usize),
        (310030usize, 310168usize),
        (312972usize, 313108usize),
        (445431usize, 445606usize),
        (454460usize, 454594usize),
        (464576usize, 464738usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            3488usize,
            9836usize,
            12718usize,
            52574usize,
            64603usize,
            77997usize,
            119307usize,
            121918usize,
            201073usize,
            212698usize,
            215343usize,
            241826usize,
            288269usize,
            310030usize,
            312972usize,
            445431usize,
            454460usize,
            464576usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_then_child_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (3488usize, 3628usize),
        (9836usize, 10004usize),
        (12718usize, 12882usize),
        (52574usize, 52738usize),
        (64603usize, 64737usize),
        (77997usize, 78134usize),
        (119307usize, 119445usize),
        (121918usize, 122066usize),
        (201073usize, 201238usize),
        (212698usize, 212847usize),
        (215343usize, 215493usize),
        (241826usize, 241966usize),
        (288269usize, 288425usize),
        (310030usize, 310168usize),
        (312972usize, 313108usize),
        (445431usize, 445606usize),
        (454460usize, 454594usize),
        (464576usize, 464738usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 44u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            3488usize,
            3504usize,
            5803usize,
            5955usize,
            9836usize,
            9852usize,
            12718usize,
            12734usize,
            12913usize,
            52574usize,
            52590usize,
            64603usize,
            64619usize,
            77997usize,
            78013usize,
            78165usize,
            119307usize,
            119323usize,
            121918usize,
            121934usize,
            122097usize,
            201073usize,
            201089usize,
            212698usize,
            212714usize,
            212878usize,
            215343usize,
            215359usize,
            241826usize,
            241842usize,
            274278usize,
            288269usize,
            288285usize,
            310030usize,
            310046usize,
            312972usize,
            312988usize,
            445431usize,
            445447usize,
            454460usize,
            454476usize,
            464576usize,
            464592usize,
            464769usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (3488usize, 3628usize),
        (3504usize, 3528usize),
        (5803usize, 5827usize),
        (5955usize, 5979usize),
        (9836usize, 10004usize),
        (9852usize, 9876usize),
        (12718usize, 12882usize),
        (12734usize, 12758usize),
        (12913usize, 12937usize),
        (52574usize, 52738usize),
        (52590usize, 52614usize),
        (64603usize, 64737usize),
        (64619usize, 64643usize),
        (77997usize, 78134usize),
        (78013usize, 78037usize),
        (78165usize, 78189usize),
        (119307usize, 119445usize),
        (119323usize, 119347usize),
        (121918usize, 122066usize),
        (121934usize, 121958usize),
        (122097usize, 122119usize),
        (201073usize, 201238usize),
        (201089usize, 201114usize),
        (212698usize, 212847usize),
        (212714usize, 212738usize),
        (212878usize, 212902usize),
        (215343usize, 215493usize),
        (215359usize, 215383usize),
        (241826usize, 241966usize),
        (241842usize, 241866usize),
        (274278usize, 274300usize),
        (288269usize, 288425usize),
        (288285usize, 288309usize),
        (310030usize, 310168usize),
        (310046usize, 310070usize),
        (312972usize, 313108usize),
        (312988usize, 313012usize),
        (445431usize, 445606usize),
        (445447usize, 445471usize),
        (454460usize, 454594usize),
        (454476usize, 454500usize),
        (464576usize, 464738usize),
        (464592usize, 464616usize),
        (464769usize, 464793usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 44u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            3488usize,
            3504usize,
            5803usize,
            5955usize,
            9836usize,
            9852usize,
            12718usize,
            12734usize,
            12913usize,
            52574usize,
            52590usize,
            64603usize,
            64619usize,
            77997usize,
            78013usize,
            78165usize,
            119307usize,
            119323usize,
            121918usize,
            121934usize,
            122097usize,
            201073usize,
            201089usize,
            212698usize,
            212714usize,
            212878usize,
            215343usize,
            215359usize,
            241826usize,
            241842usize,
            274278usize,
            288269usize,
            288285usize,
            310030usize,
            310046usize,
            312972usize,
            312988usize,
            445431usize,
            445447usize,
            454460usize,
            454476usize,
            464576usize,
            464592usize,
            464769usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (3488usize, 3628usize),
        (3504usize, 3528usize),
        (5803usize, 5827usize),
        (5955usize, 5979usize),
        (9836usize, 10004usize),
        (9852usize, 9876usize),
        (12718usize, 12882usize),
        (12734usize, 12758usize),
        (12913usize, 12937usize),
        (52574usize, 52738usize),
        (52590usize, 52614usize),
        (64603usize, 64737usize),
        (64619usize, 64643usize),
        (77997usize, 78134usize),
        (78013usize, 78037usize),
        (78165usize, 78189usize),
        (119307usize, 119445usize),
        (119323usize, 119347usize),
        (121918usize, 122066usize),
        (121934usize, 121958usize),
        (122097usize, 122119usize),
        (201073usize, 201238usize),
        (201089usize, 201114usize),
        (212698usize, 212847usize),
        (212714usize, 212738usize),
        (212878usize, 212902usize),
        (215343usize, 215493usize),
        (215359usize, 215383usize),
        (241826usize, 241966usize),
        (241842usize, 241866usize),
        (274278usize, 274300usize),
        (288269usize, 288425usize),
        (288285usize, 288309usize),
        (310030usize, 310168usize),
        (310046usize, 310070usize),
        (312972usize, 313108usize),
        (312988usize, 313012usize),
        (445431usize, 445606usize),
        (445447usize, 445471usize),
        (454460usize, 454594usize),
        (454476usize, 454500usize),
        (464576usize, 464738usize),
        (464592usize, 464616usize),
        (464769usize, 464793usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 44u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            3488usize,
            3504usize,
            5803usize,
            5955usize,
            9836usize,
            9852usize,
            12718usize,
            12734usize,
            12913usize,
            52574usize,
            52590usize,
            64603usize,
            64619usize,
            77997usize,
            78013usize,
            78165usize,
            119307usize,
            119323usize,
            121918usize,
            121934usize,
            122097usize,
            201073usize,
            201089usize,
            212698usize,
            212714usize,
            212878usize,
            215343usize,
            215359usize,
            241826usize,
            241842usize,
            274278usize,
            288269usize,
            288285usize,
            310030usize,
            310046usize,
            312972usize,
            312988usize,
            445431usize,
            445447usize,
            454460usize,
            454476usize,
            464576usize,
            464592usize,
            464769usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_descendant_user_entities_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (3488usize, 3628usize),
        (3504usize, 3528usize),
        (5803usize, 5827usize),
        (5955usize, 5979usize),
        (9836usize, 10004usize),
        (9852usize, 9876usize),
        (12718usize, 12882usize),
        (12734usize, 12758usize),
        (12913usize, 12937usize),
        (52574usize, 52738usize),
        (52590usize, 52614usize),
        (64603usize, 64737usize),
        (64619usize, 64643usize),
        (77997usize, 78134usize),
        (78013usize, 78037usize),
        (78165usize, 78189usize),
        (119307usize, 119445usize),
        (119323usize, 119347usize),
        (121918usize, 122066usize),
        (121934usize, 121958usize),
        (122097usize, 122119usize),
        (201073usize, 201238usize),
        (201089usize, 201114usize),
        (212698usize, 212847usize),
        (212714usize, 212738usize),
        (212878usize, 212902usize),
        (215343usize, 215493usize),
        (215359usize, 215383usize),
        (241826usize, 241966usize),
        (241842usize, 241866usize),
        (274278usize, 274300usize),
        (288269usize, 288425usize),
        (288285usize, 288309usize),
        (310030usize, 310168usize),
        (310046usize, 310070usize),
        (312972usize, 313108usize),
        (312988usize, 313012usize),
        (445431usize, 445606usize),
        (445447usize, 445471usize),
        (454460usize, 454594usize),
        (454476usize, 454500usize),
        (464576usize, 464738usize),
        (464592usize, 464616usize),
        (464769usize, 464793usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_count_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![466869usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(466869usize, 466872usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_compressed_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/compressed/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            5465usize,
            18496usize,
            23338usize,
            89785usize,
            112198usize,
            134220usize,
            201055usize,
            205281usize,
            333130usize,
            352432usize,
            357000usize,
            399785usize,
            475584usize,
            511442usize,
            516538usize,
            728252usize,
            743602usize,
            762797usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5465usize, 5978usize),
        (18496usize, 19037usize),
        (23338usize, 23875usize),
        (89785usize, 90370usize),
        (112198usize, 112753usize),
        (134220usize, 134778usize),
        (201055usize, 201566usize),
        (205281usize, 205850usize),
        (333130usize, 333668usize),
        (352432usize, 352954usize),
        (357000usize, 357571usize),
        (399785usize, 400346usize),
        (475584usize, 476113usize),
        (511442usize, 511953usize),
        (516538usize, 517047usize),
        (728252usize, 728800usize),
        (743602usize, 744157usize),
        (762797usize, 763332usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            5465usize,
            18496usize,
            23338usize,
            89785usize,
            112198usize,
            134220usize,
            201055usize,
            205281usize,
            333130usize,
            352432usize,
            357000usize,
            399785usize,
            475584usize,
            511442usize,
            516538usize,
            728252usize,
            743602usize,
            762797usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5465usize, 5978usize),
        (18496usize, 19037usize),
        (23338usize, 23875usize),
        (89785usize, 90370usize),
        (112198usize, 112753usize),
        (134220usize, 134778usize),
        (201055usize, 201566usize),
        (205281usize, 205850usize),
        (333130usize, 333668usize),
        (352432usize, 352954usize),
        (357000usize, 357571usize),
        (399785usize, 400346usize),
        (475584usize, 476113usize),
        (511442usize, 511953usize),
        (516538usize, 517047usize),
        (728252usize, 728800usize),
        (743602usize, 744157usize),
        (762797usize, 763332usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 18u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            5465usize,
            18496usize,
            23338usize,
            89785usize,
            112198usize,
            134220usize,
            201055usize,
            205281usize,
            333130usize,
            352432usize,
            357000usize,
            399785usize,
            475584usize,
            511442usize,
            516538usize,
            728252usize,
            743602usize,
            762797usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_then_child_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities.url (descendant user entities, then child url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities.url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5465usize, 5978usize),
        (18496usize, 19037usize),
        (23338usize, 23875usize),
        (89785usize, 90370usize),
        (112198usize, 112753usize),
        (134220usize, 134778usize),
        (201055usize, 201566usize),
        (205281usize, 205850usize),
        (333130usize, 333668usize),
        (352432usize, 352954usize),
        (357000usize, 357571usize),
        (399785usize, 400346usize),
        (475584usize, 476113usize),
        (511442usize, 511953usize),
        (516538usize, 517047usize),
        (728252usize, 728800usize),
        (743602usize, 744157usize),
        (762797usize, 763332usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 44u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            5465usize,
            5570usize,
            9496usize,
            9985usize,
            18496usize,
            18601usize,
            23338usize,
            23443usize,
            24017usize,
            89785usize,
            89902usize,
            112198usize,
            112315usize,
            134220usize,
            134337usize,
            134936usize,
            201055usize,
            201160usize,
            205281usize,
            205398usize,
            206008usize,
            333130usize,
            333235usize,
            352432usize,
            352537usize,
            353096usize,
            357000usize,
            357117usize,
            399785usize,
            399902usize,
            451854usize,
            475584usize,
            475689usize,
            511442usize,
            511547usize,
            516538usize,
            516643usize,
            728252usize,
            728357usize,
            743602usize,
            743719usize,
            762797usize,
            762902usize,
            763474usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5465usize, 5978usize),
        (5570usize, 5594usize),
        (9496usize, 9520usize),
        (9985usize, 10009usize),
        (18496usize, 19037usize),
        (18601usize, 18625usize),
        (23338usize, 23875usize),
        (23443usize, 23467usize),
        (24017usize, 24041usize),
        (89785usize, 90370usize),
        (89902usize, 89926usize),
        (112198usize, 112753usize),
        (112315usize, 112339usize),
        (134220usize, 134778usize),
        (134337usize, 134361usize),
        (134936usize, 134960usize),
        (201055usize, 201566usize),
        (201160usize, 201184usize),
        (205281usize, 205850usize),
        (205398usize, 205422usize),
        (206008usize, 206030usize),
        (333130usize, 333668usize),
        (333235usize, 333260usize),
        (352432usize, 352954usize),
        (352537usize, 352561usize),
        (353096usize, 353120usize),
        (357000usize, 357571usize),
        (357117usize, 357141usize),
        (399785usize, 400346usize),
        (399902usize, 399926usize),
        (451854usize, 451876usize),
        (475584usize, 476113usize),
        (475689usize, 475713usize),
        (511442usize, 511953usize),
        (511547usize, 511571usize),
        (516538usize, 517047usize),
        (516643usize, 516667usize),
        (728252usize, 728800usize),
        (728357usize, 728381usize),
        (743602usize, 744157usize),
        (743719usize, 743743usize),
        (762797usize, 763332usize),
        (762902usize, 762926usize),
        (763474usize, 763498usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 44u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            5465usize,
            5570usize,
            9496usize,
            9985usize,
            18496usize,
            18601usize,
            23338usize,
            23443usize,
            24017usize,
            89785usize,
            89902usize,
            112198usize,
            112315usize,
            134220usize,
            134337usize,
            134936usize,
            201055usize,
            201160usize,
            205281usize,
            205398usize,
            206008usize,
            333130usize,
            333235usize,
            352432usize,
            352537usize,
            353096usize,
            357000usize,
            357117usize,
            399785usize,
            399902usize,
            451854usize,
            475584usize,
            475689usize,
            511442usize,
            511547usize,
            516538usize,
            516643usize,
            728252usize,
            728357usize,
            743602usize,
            743719usize,
            762797usize,
            762902usize,
            763474usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5465usize, 5978usize),
        (5570usize, 5594usize),
        (9496usize, 9520usize),
        (9985usize, 10009usize),
        (18496usize, 19037usize),
        (18601usize, 18625usize),
        (23338usize, 23875usize),
        (23443usize, 23467usize),
        (24017usize, 24041usize),
        (89785usize, 90370usize),
        (89902usize, 89926usize),
        (112198usize, 112753usize),
        (112315usize, 112339usize),
        (134220usize, 134778usize),
        (134337usize, 134361usize),
        (134936usize, 134960usize),
        (201055usize, 201566usize),
        (201160usize, 201184usize),
        (205281usize, 205850usize),
        (205398usize, 205422usize),
        (206008usize, 206030usize),
        (333130usize, 333668usize),
        (333235usize, 333260usize),
        (352432usize, 352954usize),
        (352537usize, 352561usize),
        (353096usize, 353120usize),
        (357000usize, 357571usize),
        (357117usize, 357141usize),
        (399785usize, 400346usize),
        (399902usize, 399926usize),
        (451854usize, 451876usize),
        (475584usize, 476113usize),
        (475689usize, 475713usize),
        (511442usize, 511953usize),
        (511547usize, 511571usize),
        (516538usize, 517047usize),
        (516643usize, 516667usize),
        (728252usize, 728800usize),
        (728357usize, 728381usize),
        (743602usize, 744157usize),
        (743719usize, 743743usize),
        (762797usize, 763332usize),
        (762902usize, 762926usize),
        (763474usize, 763498usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 44u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(
        result,
        vec![
            5465usize,
            5570usize,
            9496usize,
            9985usize,
            18496usize,
            18601usize,
            23338usize,
            23443usize,
            24017usize,
            89785usize,
            89902usize,
            112198usize,
            112315usize,
            134220usize,
            134337usize,
            134936usize,
            201055usize,
            201160usize,
            205281usize,
            205398usize,
            206008usize,
            333130usize,
            333235usize,
            352432usize,
            352537usize,
            353096usize,
            357000usize,
            357117usize,
            399785usize,
            399902usize,
            451854usize,
            475584usize,
            475689usize,
            511442usize,
            511547usize,
            516538usize,
            516643usize,
            728252usize,
            728357usize,
            743602usize,
            743719usize,
            762797usize,
            762902usize,
            763474usize,
        ],
        "result != expected"
    );
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_descendant_user_entities_url_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..user..entities..url (descendant user entities url) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..user..entities..url")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![
        (5465usize, 5978usize),
        (5570usize, 5594usize),
        (9496usize, 9520usize),
        (9985usize, 10009usize),
        (18496usize, 19037usize),
        (18601usize, 18625usize),
        (23338usize, 23875usize),
        (23443usize, 23467usize),
        (24017usize, 24041usize),
        (89785usize, 90370usize),
        (89902usize, 89926usize),
        (112198usize, 112753usize),
        (112315usize, 112339usize),
        (134220usize, 134778usize),
        (134337usize, 134361usize),
        (134936usize, 134960usize),
        (201055usize, 201566usize),
        (201160usize, 201184usize),
        (205281usize, 205850usize),
        (205398usize, 205422usize),
        (206008usize, 206030usize),
        (333130usize, 333668usize),
        (333235usize, 333260usize),
        (352432usize, 352954usize),
        (352537usize, 352561usize),
        (353096usize, 353120usize),
        (357000usize, 357571usize),
        (357117usize, 357141usize),
        (399785usize, 400346usize),
        (399902usize, 399926usize),
        (451854usize, 451876usize),
        (475584usize, 476113usize),
        (475689usize, 475713usize),
        (511442usize, 511953usize),
        (511547usize, 511571usize),
        (516538usize, 517047usize),
        (516643usize, 516667usize),
        (728252usize, 728800usize),
        (728357usize, 728381usize),
        (743602usize, 744157usize),
        (743719usize, 743743usize),
        (762797usize, 763332usize),
        (762902usize, 762926usize),
        (763474usize, 763498usize),
    ];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..count (select count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_and_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata..count (select metadata and count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_by_descendant_should_use_memchr_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $..search_metadata.count (select metadata count by descendant (should use memchr)) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_count_directly_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata.count (select metadata count directly) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata.count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![767233usize,], "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(767233usize, 767236usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn twitter_json_from_simdjson_github_example_with_query_select_metadata_directly_and_then_count_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document twitter.toml running the query $.search_metadata..count (select metadata directly, and then count by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.search_metadata..count")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/large/twitter.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["100"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0,1,2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0,1,2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_child_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0,1,2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0,1,2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0,1,2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(5usize, 12usize, 12usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![5usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(5usize, 12usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_a_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0,1,2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 7usize, 7usize),
        (8usize, 9usize, 9usize),
        (10usize, 11usize, 11usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 8usize, 10usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 7usize), (8usize, 9usize), (10usize, 11usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "1", "2"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 7usize, 7usize),
        (8usize, 9usize, 9usize),
        (10usize, 11usize, 11usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 8usize, 10usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 7usize), (8usize, 9usize), (10usize, 11usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "1", "2"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (6usize, 7usize, 7usize),
        (8usize, 9usize, 9usize),
        (10usize, 11usize, 11usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![6usize, 8usize, 10usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(6usize, 7usize), (8usize, 9usize), (10usize, 11usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "1", "2"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"a\":[0,1,2]}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"a\":[0,1,2]}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 13usize, 13usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 13usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_compressed_with_query_select_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document compressed/index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/compressed/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"a\":[0,1,2]}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(9usize, 24usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![9usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(9usize, 24usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0  ,  1  ,  2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(9usize, 24usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![9usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(9usize, 24usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0  ,  1  ,  2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(9usize, 24usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![9usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(9usize, 24usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_child_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a (select a by child) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0  ,  1  ,  2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(9usize, 24usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![9usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(9usize, 24usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0  ,  1  ,  2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(9usize, 24usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![9usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(9usize, 24usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0  ,  1  ,  2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(9usize, 24usize, 24usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![9usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(9usize, 24usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_a_by_descendant_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $..a (select a by descendant) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$..a")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["[0  ,  1  ,  2]"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (10usize, 11usize, 13usize),
        (16usize, 17usize, 19usize),
        (22usize, 23usize, 23usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![10usize, 16usize, 22usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(10usize, 11usize), (16usize, 17usize), (22usize, 23usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "1", "2"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (10usize, 11usize, 13usize),
        (16usize, 17usize, 19usize),
        (22usize, 23usize, 23usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![10usize, 16usize, 22usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(10usize, 11usize), (16usize, 17usize), (22usize, 23usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "1", "2"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![
        (10usize, 11usize, 13usize),
        (16usize, 17usize, 19usize),
        (22usize, 23usize, 23usize),
    ];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 3u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![10usize, 16usize, 22usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(10usize, 11usize), (16usize, 17usize), (22usize, 23usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_each_item_on_the_list_with_wildcard_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $.a[*] (select each item on the list with wildcard) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$.a[*]")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["0", "1", "2"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_buffered_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 25usize, 26usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_buffered_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_buffered_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_buffered_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_buffered_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl BufferedInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = BufferedInput::new(json_file);
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"a\"  :  [0  ,  1  ,  2]}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_mmap_input_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl MmapInput and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 25usize, 26usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_mmap_input_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl MmapInput and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_mmap_input_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl MmapInput and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_mmap_input_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl MmapInput and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_mmap_input_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl MmapInput and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let json_file = fs::File::open("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = unsafe { MmapInput::map_file(&json_file)? };
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"a\"  :  [0  ,  1  ,  2]}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_owned_bytes_and_approx_span_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode ApproxSpanResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.approximate_spans(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result.iter().map(|x| (x.start_idx(), x.end_idx())).collect();
    let expected: Vec<(usize, usize, usize)> = vec![(0usize, 25usize, 26usize)];
    assert_eq!(tups.len(), expected.len(), "result.len() != expected.len()");
    for i in 0..tups.len() {
        let upper_bound = expected[i];
        let actual = tups[i];
        assert_eq!(actual.0, upper_bound.0, "result start_idx() != expected start_idx()");
        assert!(
            actual.1 >= upper_bound.1,
            "result end_idx() < expected end_lower_bound ({} < {})",
            actual.1,
            upper_bound.1
        );
        assert!(
            actual.1 <= upper_bound.2,
            "result end_idx() > expected end_upper_bound ({} > {}",
            actual.1,
            upper_bound.2
        );
    }
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_owned_bytes_and_count_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode CountResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let result = engine.count(&input)?;
    assert_eq!(result, 1u64, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_owned_bytes_and_index_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode IndexResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.indices(&input, &mut result)?;
    assert_eq!(result, vec![0usize,], "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_owned_bytes_and_nodes_result_span_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode NodesResult(Span)");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let tups: Vec<(usize, usize)> = result
        .iter()
        .map(|x| (x.span().start_idx(), x.span().end_idx()))
        .collect();
    let expected: Vec<(usize, usize)> = vec![(0usize, 25usize)];
    assert_eq!(tups, expected, "result != expected");
    Ok(())
}
#[test]
fn whitespace_separators_between_structurals_to_test_correctness_of_index_result_handling_with_query_select_root_with_owned_bytes_and_nodes_result_using_main_engine(
) -> Result<(), Box<dyn Error>> {
    println ! ("on document index_result.toml running the query $ (select root) with Input impl OwnedBytes and result mode NodesResult");
    let jsonpath_query = JsonPathQuery::parse("$")?;
    let raw_json = fs::read_to_string("../rsonpath-lib/tests/documents/json/index_result.json")?;
    let input = OwnedBytes::new(&raw_json.as_bytes())?;
    let engine = MainEngine::compile_query(&jsonpath_query)?;
    let mut result = vec![];
    engine.matches(&input, &mut result)?;
    let utf8: Result<Vec<&str>, _> = result.iter().map(|x| str::from_utf8(x.bytes())).collect();
    let utf8 = utf8.expect("valid utf8");
    let expected: Vec<&str> = vec!["{\"a\"  :  [0  ,  1  ,  2]}"];
    assert_eq!(utf8, expected, "result != expected");
    Ok(())
}
